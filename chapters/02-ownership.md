# Chapter 02: 所有権

> **この章で学ぶこと**: 所有権、借用、ライフタイム — Rust最大の特徴にして最重要概念

---

## 🎯 なぜ所有権が必要なのか

Python/TypeScriptを使っていると、メモリ管理を意識することはほとんどありません。それは**ガベージコレクタ（GC）**が自動でやってくれるからです。

```python
# Python
def create_list():
    data = [1, 2, 3, 4, 5]  # メモリを確保
    return data
    # 関数終了後、dataへの参照がなくなったらGCが解放

result = create_list()
# GCが「result」がまだ参照されているか定期的にチェック
```

GCは便利ですが、問題もあります：

1. **パフォーマンスコスト**: GCが動くと一瞬プログラムが止まる（Stop-the-World）
2. **予測不能性**: いつGCが動くか分からない（リアルタイム処理に不向き）
3. **メモリ使用量**: 解放が遅れるため、メモリを多く消費

C/C++はGCを使わず手動でメモリ管理しますが、今度は別の問題が発生します：

```c
// C言語の危険なコード
int* create_array() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // 危険！ローカル変数へのポインタを返している
}  // arrは関数終了時に解放される → ダングリングポインタ
```

**Rustの解決策**: 「所有権システム」により、**コンパイル時に**メモリの有効期間を決定。GCなしで安全にメモリ管理できます。

---

## 所有権の3つのルール

🎯 **これだけ覚えれば8割OK**:

1. **Rustのすべての値には「所有者」となる変数がある**
2. **所有者は常に1つだけ**
3. **所有者がスコープを抜けると、値は自動的に破棄される**

---

## スコープと破棄

```rust
fn main() {
    {
        let s = String::from("hello");  // sが所有者になる
        println!("{}", s);
    }  // sがスコープを抜ける → メモリ解放（drop）
    
    // println!("{}", s);  // ❌ エラー！sはもう存在しない
}
```

これはPythonやJSと似ていますが、重要な違いがあります：
- **Python/JS**: GCが「後で」解放（いつかは不明）
- **Rust**: スコープを抜けた**瞬間に**解放（確定的）

---

## ムーブ（移動）— 所有権の移転

ここからがRust独特の概念です。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // 所有権がs1からs2に「ムーブ」
    
    println!("{}", s1);  // ❌ コンパイルエラー！
    println!("{}", s2);  // ✅ OK
}
```

🔄 **比較（Python）**:
```python
s1 = "hello"
s2 = s1  # 参照のコピー（両方が同じオブジェクトを指す）
print(s1)  # ✅ OK
print(s2)  # ✅ OK
```

Rustでは`s2 = s1`で「所有権が移動」します。これは「浅いコピー + s1の無効化」と考えられます。

### なぜムーブが必要なのか

```
メモリ状態の図解:

s1 = String::from("hello") の後:
┌──────────┐     ┌──────────┐
│ s1       │     │ ヒープ    │
├──────────┤     ├──────────┤
│ ptr ─────────> │ "hello"  │
│ len: 5   │     └──────────┘
│ cap: 5   │
└──────────┘

s2 = s1 の後（ムーブ）:
┌──────────┐     ┌──────────┐
│ s1(無効) │     │ ヒープ    │
├──────────┤     ├──────────┤
│ (使用不可)     │ "hello"  │
└──────────┘     └──────────┘
                      ↑
┌──────────┐          │
│ s2       │          │
├──────────┤          │
│ ptr ─────────────────
│ len: 5   │
│ cap: 5   │
└──────────┘
```

もしs1とs2の両方が有効だと、スコープを抜けるときに**同じメモリを2回解放**（二重解放）してしまいます。これはメモリ破壊の原因になります。

Rustは「所有者は1つだけ」ルールにより、この問題をコンパイル時に防ぎます。

### Copyトレイト — ムーブしない型

整数などのスタック上に収まる単純な型は「コピー」されます。

```rust
fn main() {
    let x = 5;
    let y = x;  // コピー（ムーブではない）
    
    println!("x = {}, y = {}", x, y);  // ✅ 両方使える
}
```

Copyトレイトを実装している型：
- 整数型（`i32`, `u64`など）
- 浮動小数点数（`f32`, `f64`）
- ブール型（`bool`）
- 文字型（`char`）
- 上記のみで構成されるタプル

**ヒープを使う型**（`String`, `Vec<T>`など）はムーブします。

---

## 借用（Borrowing）— 所有権を渡さずに使う

毎回ムーブしていては不便です。「借用」を使えば、所有権を保持したまま値を使えます。

### 不変の借用（`&`）

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // &sは「sの参照」
    println!("'{}' の長さは {}", s, len);  // sはまだ使える
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // sは借用なので、ここでdropされない
```

🔄 **比較（Python）**:
```python
def calculate_length(s):
    return len(s)

s = "hello"
length = calculate_length(s)  # Pythonは常に参照渡し
print(f"'{s}' の長さは {length}")  # OK
```

Pythonでは「参照渡し」が当たり前ですが、Rustでは「借用」を明示的に書きます。

### 可変の借用（`&mut`）

値を変更したい場合は`&mut`を使います。

```rust
fn main() {
    let mut s = String::from("hello");  // mutが必要
    change(&mut s);
    println!("{}", s);  // "hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

### 借用のルール

⚠️ **重要なルール**:

1. **不変の借用（`&T`）は同時に複数OK**
2. **可変の借用（`&mut T`）は同時に1つだけ**
3. **不変の借用と可変の借用は同時に存在できない**

```rust
fn main() {
    let mut s = String::from("hello");
    
    // ✅ OK: 不変の借用は複数持てる
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);
    
    // ✅ OK: r1, r2はここで使われなくなる
    let r3 = &mut s;
    println!("{}", r3);
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;
    let r2 = &mut s;  // ❌ エラー！不変借用と可変借用の同時使用
    println!("{}, {}", r1, r2);
}
```

### なぜこのルールが必要か

これは**データ競合**を防ぐためです。

```
データ競合の条件（すべて満たすと発生）:
1. 2つ以上のポインタが同じデータにアクセス
2. 少なくとも1つが書き込み
3. アクセスが同期されていない
```

Rustの借用ルールは、この条件を**コンパイル時に**検出して防ぎます。

🔄 **比較（JavaScript）**:
```javascript
const arr = [1, 2, 3];

// 配列を反復しながら変更 → 予期しない動作
arr.forEach((item, i) => {
    if (item === 2) arr.push(4);  // 反復中に変更！
});
```

Rustではこのようなコードはコンパイルエラーになります。

---

## ライフタイム — 参照の有効期間

参照が「どのくらい生きているか」を表すのが**ライフタイム**です。

### ダングリング参照の防止

```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;  // ❌ エラー！xはこのスコープで消える
    }
    println!("{}", r);  // xはもう存在しない
}
```

Rustコンパイラは「rがxより長生きしようとしている」ことを検出し、エラーにします。

### ライフタイム注釈

関数が参照を返す場合、ライフタイムを明示することがあります。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

`'a`は「ライフタイムパラメータ」です。「xとyは同じライフタイム`'a`を持ち、戻り値も`'a`の間有効」という意味です。

💡 **Tips**: 最初はライフタイム注釈に戸惑いますが、多くの場合コンパイラが推論してくれます。エラーが出たら、エラーメッセージに従って追加すればOKです。

---

## スタックとヒープ

所有権を理解するには、メモリの仕組みを知っておくと役立ちます。

| 領域 | 特徴 | 格納されるもの | アクセス速度 |
|-----|------|--------------|------------|
| スタック | 固定サイズ、LIFO | 整数、固定長配列、参照 | 高速 |
| ヒープ | 可変サイズ、動的確保 | String, Vec, Boxなど | やや遅い |

```rust
fn main() {
    let x = 5;               // スタック上に直接格納
    let s = String::from("hello");  // ヒープにデータ、スタックにポインタ
    
    let y = x;   // スタックにコピー（高速）
    let t = s;   // ポインタのコピー + ムーブ
}
```

🔄 **比較**:
- **Python/JS**: すべてヒープ上のオブジェクト（GCが管理）
- **Rust**: プログラマが意識してスタック/ヒープを使い分け

---

## 実践パターン

### 関数に値を渡す

```rust
// 所有権を取る（呼び出し元は使えなくなる）
fn takes_ownership(s: String) {
    println!("{}", s);
}

// 借用する（呼び出し元も使える）
fn borrows(s: &String) {
    println!("{}", s);
}

// 可変借用（変更できる）
fn mutates(s: &mut String) {
    s.push_str("!");
}

fn main() {
    let s1 = String::from("hello");
    takes_ownership(s1);
    // println!("{}", s1);  // ❌ s1はムーブ済み
    
    let s2 = String::from("hello");
    borrows(&s2);
    println!("{}", s2);  // ✅ OK
    
    let mut s3 = String::from("hello");
    mutates(&mut s3);
    println!("{}", s3);  // "hello!"
}
```

### Cloneで明示的にコピー

本当にコピーが必要な場合は`clone()`を使います。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深いコピー（ヒープデータもコピー）
    
    println!("s1 = {}, s2 = {}", s1, s2);  // ✅ 両方使える
}
```

⚠️ **注意**: `clone()`はヒープデータもコピーするのでコストがかかります。必要な場合のみ使いましょう。

---

## まとめ

| 概念 | 説明 | Python/TSとの違い |
|-----|------|------------------|
| 所有権 | 値には所有者が1つだけ | GC言語では意識不要 |
| ムーブ | 代入で所有権が移動 | 参照のコピー（両方使える） |
| 借用 | `&`で参照を作成 | 明示的に書く必要がある |
| `&mut` | 可変借用（同時に1つだけ） | 制限なし（データ競合のリスク） |
| ライフタイム | 参照の有効期間 | GCが管理 |

🎯 **ポイント**:
- 所有権システムにより、GCなしでメモリ安全を保証
- 「コンパイラと対話」— エラーが出たらメッセージをよく読む
- 最初は戸惑うが、慣れると「バグが実行前に見つかる」安心感がある

---

## 次のステップ

[Chapter 03: 構造体・列挙型](03-structs-enums.md) では、Rustでデータを構造化する方法を学びます。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能です。
