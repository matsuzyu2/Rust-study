# Chapter 02: 所有権

> **この章で学ぶこと**: 所有権、借用（`&`と`&mut`）、ライフタイム — Rust最大の特徴にして最重要概念

> 📖 **記号リファレンス**: この章では `&`, `&mut`, `'a` など重要な記号が登場します。意味がわからなくなったら [Chapter 11: 記号・構文リファレンス](11-syntax-reference.md) を参照してください。

---

## 🎯 なぜ所有権が必要なのか — 本当の理由

Python/TypeScriptを使っていると、メモリ管理を意識することはほとんどありません。それは**ガベージコレクタ（GC）**が自動でやってくれるからです。

```python
# Python
def create_list():
    data = [1, 2, 3, 4, 5]  # メモリを確保
    return data
    # 関数終了後、dataへの参照がなくなったらGCが解放

result = create_list()
# GCが「result」がまだ参照されているか定期的にチェック
```

GCは便利ですが、**実は大きなコスト**を払っています：

### GCの問題点

```
┌─────────────────────────────────────────────────────────────────┐
│  ガベージコレクタの隠れたコスト                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. パフォーマンスの一時停止（Stop-the-World）                   │
│     → GCが動くと数ms〜数百msプログラムが停止                      │
│     → リアルタイム処理（ゲーム、取引システム）では致命的          │
│                                                                 │
│  2. 予測不能性                                                   │
│     → いつGCが動くか分からない                                   │
│     → レイテンシが安定しない                                     │
│                                                                 │
│  3. メモリ使用量の増大                                           │
│     → 解放が遅れるため、必要以上にメモリを消費                    │
│     → Python/Nodeは同じ処理でもRustの数倍メモリを使う             │
│                                                                 │
│  4. CPUオーバーヘッド                                            │
│     → 参照カウントの更新（Python）                               │
│     → マーク＆スイープのトラバーサル                              │
└─────────────────────────────────────────────────────────────────┘
```

### 手動メモリ管理（C/C++）の問題点

一方、C/C++のようにGCを使わず手動でメモリ管理すると、別の深刻な問題が発生します：

```c
// C言語: ダングリングポインタ（解放済みメモリへのポインタ）
int* create_array() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // 危険！ローカル変数へのポインタを返している
}  // arrは関数終了時に解放される → ダングリングポインタ

// C言語: 二重解放
int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 未定義動作！メモリ破壊やクラッシュの原因
```

これらのバグは**実行時まで気づかない**ことが多く、セキュリティ脆弱性の最大の原因です。

### Rustの革新的な解決策

```
┌─────────────────────────────────────────────────────────────────┐
│  Rustの所有権システム                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  「コンパイル時に」メモリの有効期間を完全に決定                    │
│                                                                 │
│  結果:                                                           │
│  ✅ GCなし → 予測可能なパフォーマンス、低メモリ使用量             │
│  ✅ 安全 → ダングリングポインタ、二重解放はコンパイルエラー        │
│  ✅ データ競合なし → マルチスレッドも安全                         │
│                                                                 │
│  代償:                                                           │
│  ⚠️ 学習コスト → 所有権の概念を理解する必要がある                 │
│  ⚠️ コンパイルエラーとの対話 → 最初は多くのエラーに遭遇           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 所有権の3つのルール

🎯 **これだけ覚えれば8割OK**:

1. **Rustのすべての値には「所有者」となる変数がある**
2. **所有者は常に1つだけ**
3. **所有者がスコープを抜けると、値は自動的に破棄される**

これがRustの「所有権システム」の全体像です。以下で一つずつ詳しく見ていきましょう。

---

## スコープと破棄

```rust
fn main() {
    {
        let s = String::from("hello");  // sが所有者になる
        println!("{}", s);
    }  // sがスコープを抜ける → メモリ解放（drop）
    
    // println!("{}", s);  // ❌ エラー！sはもう存在しない
}
```

### このコードで何が起きているか

```
時間の流れ →

1. { が始まる
   スタック: [空]
   ヒープ: [空]

2. let s = String::from("hello");
   スタック: [s: {ptr, len: 5, cap: 5}]
   ヒープ: ["hello" のバイト列]

3. println!("{}", s);
   sを通じてヒープのデータを読む

4. } でスコープ終了
   → Rustが自動的に drop(s) を呼ぶ
   → ヒープの "hello" が解放される
   スタック: [空]
   ヒープ: [空]
```

**PythonやTypeScriptとの違い**:
| | Python/TypeScript | Rust |
|---|---|---|
| 解放のタイミング | GCが「後で」解放（いつかは不明） | スコープを抜けた**瞬間に**解放 |
| 予測可能性 | 低い | 高い |
| リソース管理 | `with`文や`try-finally`が必要 | 自動（RAII） |

---

## ムーブ（移動）— 所有権の移転

ここからがRust独特の概念です。**代入で所有権が「移動」**します。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // 所有権がs1からs2に「ムーブ」
    
    println!("{}", s1);  // ❌ コンパイルエラー！
    println!("{}", s2);  // ✅ OK
}
```

**コンパイルエラーの内容**:
```
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:20
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
```

### なぜムーブが起きるのか — メモリの視点で理解する

```
┌─────────────────────────────────────────────────────────────────┐
│  s1 = String::from("hello") の後のメモリ状態                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                      ヒープ                            │
│  ┌─────────────────┐          ┌──────────────────┐              │
│  │ s1              │          │ インデックス  値  │              │
│  ├─────────────────┤          ├──────────────────┤              │
│  │ ptr ────────────│────────→ │ 0           'h'  │              │
│  │ len: 5          │          │ 1           'e'  │              │
│  │ capacity: 5     │          │ 2           'l'  │              │
│  └─────────────────┘          │ 3           'l'  │              │
│                               │ 4           'o'  │              │
│  ※ ptr, len, capはスタック上    └──────────────────┘              │
│  ※ 実際の文字データはヒープ上                                     │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  s2 = s1 の後のメモリ状態（ムーブ後）                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                      ヒープ                            │
│  ┌─────────────────┐          ┌──────────────────┐              │
│  │ s1 (無効)       │          │ インデックス  値  │              │
│  ├─────────────────┤          ├──────────────────┤              │
│  │ (使用不可)      │          │ 0           'h'  │              │
│  │                 │     ┌──→ │ 1           'e'  │              │
│  └─────────────────┘     │    │ 2           'l'  │              │
│                          │    │ 3           'l'  │              │
│  ┌─────────────────┐     │    │ 4           'o'  │              │
│  │ s2              │     │    └──────────────────┘              │
│  ├─────────────────┤     │                                      │
│  │ ptr ────────────│─────┘    s1のptr, len, capがs2にコピーされ │
│  │ len: 5          │          s1は「無効」としてマークされる      │
│  │ capacity: 5     │                                            │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

### もし両方が有効だったら何が起きる？

```
危険な仮想シナリオ（Rustでは起きないが、Cでは起きうる）:

1. s1とs2が両方とも同じヒープデータを指している
2. } でスコープ終了
3. s2のdropでヒープデータを解放
4. s1のdropで「既に解放されたメモリ」を再度解放しようとする
   → 二重解放（double free）→ メモリ破壊、クラッシュ、セキュリティ脆弱性
```

**Rustの解決策**: 「所有者は1つだけ」ルールにより、`s1`を無効化。これで二重解放は**原理的に不可能**になります。

### Pythonとの比較

🔄 **比較（Python）**:
```python
s1 = "hello"
s2 = s1  # 参照のコピー（両方が同じオブジェクトを指す）
print(s1)  # ✅ OK
print(s2)  # ✅ OK
# → 両方使える。GCが参照カウントを管理している
```

Pythonでは**参照カウント**という仕組みで「何個の変数がこのオブジェクトを指しているか」を追跡しています。すべての参照がなくなったときに解放されます。

```
Python のメモリモデル:
s1 = "hello"
s2 = s1

┌─────────────────┐     ┌──────────────────┐
│ s1 ─────────────│────→│ "hello"          │ ← refcount: 2
│ s2 ─────────────│────→│ (参照カウント: 2) │
└─────────────────┘     └──────────────────┘
```

---

## Copyトレイト — ムーブしない型

整数などの**スタック上に収まる単純な型**は、代入時に「ムーブ」ではなく「コピー」されます。

```rust
fn main() {
    let x = 5;
    let y = x;  // コピー（ムーブではない）
    
    println!("x = {}, y = {}", x, y);  // ✅ 両方使える
}
```

### なぜ整数はコピーなのか？

```
整数のメモリ表現:

let x = 5;
┌─────────────────┐
│ x: 5            │  ← スタック上に直接値が入る（ヒープを使わない）
└─────────────────┘

let y = x;
┌─────────────────┐
│ x: 5            │  ← そのまま
└─────────────────┘
┌─────────────────┐
│ y: 5            │  ← 値をコピー（コストは無視できるほど小さい）
└─────────────────┘
```

**Copy可能な条件**:
1. スタック上に完全に収まる（ヒープを使わない）
2. コピーのコストが非常に小さい

**Copyトレイトを実装している型**:
- 整数型（`i32`, `u64`など）
- 浮動小数点数（`f32`, `f64`）
- ブール型（`bool`）
- 文字型（`char`）
- 上記のみで構成されるタプル（例: `(i32, bool)`）

**ヒープを使う型**（`String`, `Vec<T>`, `Box<T>`など）は**ムーブ**します。

---

## 借用（Borrowing）— 所有権を渡さずに使う

毎回ムーブしていては不便です。「値を使いたいけど、所有権は渡したくない」場面は多いです。

そこで**借用（Borrowing）**を使います。

### 不変の借用（`&`）

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // &s = sへの参照（借用）
    println!("'{}' の長さは {}", s, len);  // sはまだ使える！
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // sは借用なので、ここでdropされない
```

### `&`記号を理解する

**`&`は何をしているのか？**

```
┌─────────────────────────────────────────────────────────────────┐
│  & の意味                                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  &s は「sへの参照を作る」                                        │
│                                                                 │
│  参照とは:                                                       │
│  - 値を指し示すポインタのようなもの                               │
│  - 所有権を持たない（借りているだけ）                             │
│  - 元の値が有効な間だけ使える                                     │
│                                                                 │
│  メモリ表現:                                                     │
│  ┌─────────────────┐     ┌─────────────────┐     ┌──────────┐  │
│  │ &s (参照)       │     │ s (所有者)       │     │ ヒープ   │  │
│  ├─────────────────┤     ├─────────────────┤     ├──────────┤  │
│  │ ptr ────────────│────→│ ptr ────────────│────→│ "hello"  │  │
│  └─────────────────┘     │ len: 5          │     └──────────┘  │
│                          │ cap: 5          │                   │
│                          └─────────────────┘                   │
│                                                                 │
│  参照は「所有者sのアドレス」を指す                                │
│  ヒープデータにはsを経由してアクセス                              │
└─────────────────────────────────────────────────────────────────┘
```

**`&String`型の読み方**:
- `&` = 参照
- `String` = 参照先の型
- つまり「Stringへの参照」

🔄 **比較（Python）**:
```python
def calculate_length(s):
    return len(s)

s = "hello"
length = calculate_length(s)  # Pythonは常に参照渡し（のようなもの）
print(f"'{s}' の長さは {length}")  # OK
```

Pythonでは「参照渡し」が暗黙的ですが、Rustでは「借用」を`&`で明示的に書きます。

### 可変の借用（`&mut`）

値を**変更したい**場合は`&mut`（可変参照）を使います。

```rust
fn main() {
    let mut s = String::from("hello");  // mutが必要
    change(&mut s);
    println!("{}", s);  // "hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

### `&mut`を行ごとに読み解く

```rust
let mut s = String::from("hello");
```
- `let mut` = 変更可能な変数として宣言
- これがないと可変参照を作れない

```rust
change(&mut s);
```
- `&mut s` = sへの**可変**参照を作成
- 「sを変更可能な状態で貸し出す」

```rust
fn change(s: &mut String) {
```
- `s: &mut String` = 「Stringへの可変参照」を受け取る
- この関数内でsを通じてStringを変更できる

```rust
s.push_str(", world");
```
- 可変参照を通じて元のStringに文字列を追加
- `main`関数の`s`が実際に変更される

---

## 借用の3つのルール — データ競合を防ぐ

⚠️ **Rustコンパイラが強制する重要なルール**:

```
┌─────────────────────────────────────────────────────────────────┐
│  借用のルール                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ルール1: 不変参照（&T）は同時にいくつでもOK                      │
│           → 「読み取りは何人でも同時にできる」                    │
│                                                                 │
│  ルール2: 可変参照（&mut T）は同時に1つだけ                       │
│           → 「書き込みは1人だけ」                                │
│                                                                 │
│  ルール3: 不変参照と可変参照は同時に存在できない                  │
│           → 「誰かが読んでいる間は書き込めない」                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 具体例で理解する

**OK: 不変参照は複数持てる**
```rust
fn main() {
    let s = String::from("hello");
    
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;  // いくつでもOK
    
    println!("{}, {}, {}", r1, r2, r3);
}
```

**OK: 参照を使い終わった後なら可変参照を作れる**
```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);  // r1, r2はここで最後の使用
    
    // r1, r2はもう使われない → 可変参照を作れる
    let r3 = &mut s;
    println!("{}", r3);
}
```

**NG: 不変参照と可変参照の同時使用**
```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;          // 不変参照
    let r2 = &mut s;      // ❌ エラー！
    
    println!("{}, {}", r1, r2);
}
```

**エラーメッセージ**:
```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:14
  |
4 |     let r1 = &s;
  |              -- immutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ mutable borrow occurs here
6 |     println!("{}, {}", r1, r2);
  |                        -- immutable borrow later used here
```

### なぜこのルールが必要なのか — データ競合

これは**データ競合（Data Race）**を防ぐためです。

```
┌─────────────────────────────────────────────────────────────────┐
│  データ競合の条件（すべて満たすと発生）                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 2つ以上のポインタが同じデータにアクセス                      │
│  2. 少なくとも1つが書き込み                                      │
│  3. アクセスが同期されていない                                   │
│                                                                 │
│  Rustの借用ルールは、この条件を「コンパイル時に」防ぐ             │
└─────────────────────────────────────────────────────────────────┘
```

🔄 **比較（JavaScript - Rustでは防げるバグ）**:
```javascript
const arr = [1, 2, 3];

// 配列を反復しながら変更 → 予期しない動作
arr.forEach((item, i) => {
    if (item === 2) arr.push(4);  // 反復中に変更！
});
console.log(arr);  // [1, 2, 3, 4] だが、ループ回数が変わる可能性
```

Rustでは、イテレータで借用中のコレクションを変更しようとすると**コンパイルエラー**になります。

---

## ライフタイム — 参照の有効期間

参照が「どのくらい生きているか」を表すのが**ライフタイム**です。

### ダングリング参照の防止

```rust
fn main() {
    let r;                // ← rをここで宣言
    {
        let x = 5;
        r = &x;           // ← xへの参照をrに代入
    }                     // ← xがここで破棄される
    println!("{}", r);    // ❌ xはもう存在しない！
}
```

**エラーメッセージ**:
```
error[E0597]: `x` does not live long enough
 --> src/main.rs:5:13
  |
4 |         let x = 5;
  |             - binding `x` declared here
5 |         r = &x;
  |             ^^ borrowed value does not live long enough
6 |     }
  |     - `x` dropped here while still borrowed
7 |     println!("{}", r);
  |                    - borrow later used here
```

Rustコンパイラは「rがxより長生きしようとしている」ことを検出し、エラーにします。

### コンパイラはどうやって検出するか

コンパイラは各変数に**ライフタイム**（生存期間）を割り当てます。

```rust
fn main() {
    let r;                // ─────────┐ 'a: rのライフタイム
    {                     //          │
        let x = 5;        // ─┐ 'b    │
        r = &x;           //  │       │
    }                     // ─┘ xが'bで終了、しかしrは'aで続く
    println!("{}", r);    //          │
}                         // ─────────┘
```

`'b`（xのライフタイム）が`'a`（rのライフタイム）より短いので、エラーになります。

---

## ライフタイム注釈 `'a` — 明示的なライフタイム指定

### なぜライフタイム注釈が必要か

関数が**参照を返す**場合、コンパイラは「戻り値の参照がどこまで有効か」を知る必要があります。

```rust
// ❌ コンパイルエラー！
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**エラーメッセージ**:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value,
          but the signature does not say whether it is borrowed from `x` or `y`
```

問題: 戻り値の参照は`x`から来るかもしれないし、`y`から来るかもしれない。コンパイラは「どちらのライフタイムを使えばいいか」わからない。

### ライフタイム注釈の書き方

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### `'a`を読み解く

```
┌─────────────────────────────────────────────────────────────────┐
│  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  <'a>                                                           │
│    └─ ライフタイムパラメータを宣言（型パラメータ<T>と同じ位置）   │
│                                                                 │
│  x: &'a str                                                     │
│    └─ 「xはライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  y: &'a str                                                     │
│    └─ 「yもライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  -> &'a str                                                     │
│    └─ 「戻り値もライフタイム'aの間有効」                         │
│                                                                 │
│  意味:                                                           │
│  「xとyの両方が有効な間、戻り値も有効」                          │
│  → 実際には「xとyの短い方」のライフタイムが'aになる              │
└─────────────────────────────────────────────────────────────────┘
```

### 使用例

```rust
fn main() {
    let string1 = String::from("long string is long");
    
    {
        let string2 = String::from("xyz");
        let result = longest(&string1, &string2);
        println!("Longest: {}", result);  // ✅ OK - string2はまだ有効
    }
    
    // println!("{}", result);  // resultはこのスコープでは使えない
}
```

### よく使うライフタイム

| ライフタイム | 意味 |
|------------|------|
| `'a`, `'b` | 一般的なライフタイムパラメータ |
| `'static` | プログラム全体で有効（文字列リテラルなど） |
| `'_` | ライフタイムの省略（コンパイラが推論） |

**`'static`の例**:
```rust
let s: &'static str = "Hello, world!";  // 文字列リテラルは'static
```

💡 **Tips**: 最初はライフタイム注釈に戸惑いますが、多くの場合コンパイラが推論してくれます（**ライフタイム省略規則**）。エラーが出たら、エラーメッセージに従って追加すればOKです。

---

## スタックとヒープ — メモリレイアウトの理解

所有権を深く理解するには、メモリの仕組みを知っておくと役立ちます。

### スタックとヒープの違い

| 領域 | 特徴 | 格納されるもの | アクセス速度 |
|-----|------|--------------|------------|
| スタック | 固定サイズ、LIFO、自動解放 | 整数、参照、固定長配列 | 非常に高速 |
| ヒープ | 可変サイズ、動的確保、明示的解放 | String, Vec, Boxなど | やや遅い |

### メモリレイアウトの図解

```rust
fn main() {
    let x = 5;                      // スタック上に直接格納
    let s = String::from("hello");  // ヒープにデータ、スタックにメタデータ
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│  メモリレイアウト                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック（高速、サイズ固定）         ヒープ（可変サイズ）        │
│  ┌─────────────────────────┐         ┌───────────────────┐     │
│  │ x: 5                    │         │ 'h' 'e' 'l' 'l' 'o'│     │
│  ├─────────────────────────┤         └───────────────────┘     │
│  │ s:                      │                  ↑                │
│  │   ptr ─────────────────────────────────────┘                │
│  │   len: 5                │                                   │
│  │   capacity: 5           │                                   │
│  └─────────────────────────┘                                   │
│                                                                 │
│  整数(5)は4バイトで固定 → スタックに直接                         │
│  String("hello")はサイズ可変 → ヒープにデータ                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

🔄 **比較（Python/JavaScript）**:
- **Python/JS**: ほぼすべてがヒープ上のオブジェクト（GCが管理）
- **Rust**: プログラマがスタック/ヒープを意識して使い分け

<details>
<summary>📚 上級者向け: 型ごとのスタックサイズ</summary>

```rust
use std::mem::size_of;

fn main() {
    println!("i32: {} bytes", size_of::<i32>());        // 4
    println!("i64: {} bytes", size_of::<i64>());        // 8
    println!("String: {} bytes", size_of::<String>());  // 24 (ptr + len + cap)
    println!("&str: {} bytes", size_of::<&str>());      // 16 (ptr + len)
    println!("Vec<i32>: {} bytes", size_of::<Vec<i32>>()); // 24
    println!("Box<i32>: {} bytes", size_of::<Box<i32>>()); // 8 (ポインタのみ)
}
```

`String`は24バイト（64ビットシステム）:
- ptr: 8バイト
- len: 8バイト
- capacity: 8バイト

ヒープ上の文字データは別に確保されます。

</details>

---

## 実践パターン

### パターン1: 関数に値を渡す3つの方法

```rust
// 1. 所有権を取る（呼び出し元は使えなくなる）
fn takes_ownership(s: String) {
    println!("{}", s);
}  // sがdropされる

// 2. 不変借用（呼び出し元も使える、変更不可）
fn borrows(s: &String) {
    println!("{}", s);
}  // sは借用なのでdropされない

// 3. 可変借用（変更できる）
fn mutates(s: &mut String) {
    s.push_str("!");
}

fn main() {
    let s1 = String::from("hello");
    takes_ownership(s1);
    // println!("{}", s1);  // ❌ s1はムーブ済み
    
    let s2 = String::from("hello");
    borrows(&s2);
    println!("{}", s2);  // ✅ OK "hello"
    
    let mut s3 = String::from("hello");
    mutates(&mut s3);
    println!("{}", s3);  // ✅ OK "hello!"
}
```

### パターン2: 戻り値で所有権を返す

```rust
fn create_string() -> String {
    let s = String::from("hello");
    s  // 所有権を返す
}

fn main() {
    let s = create_string();  // 所有権を受け取る
    println!("{}", s);
}
```

### パターン3: clone()で明示的にコピー

本当にコピーが必要な場合は`clone()`を使います。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深いコピー（ヒープデータもコピー）
    
    println!("s1 = {}, s2 = {}", s1, s2);  // ✅ 両方使える
}
```

⚠️ **注意**: `clone()`はヒープデータもコピーするので**コストがかかります**。必要な場合のみ使いましょう。

---

## まとめ

| 概念 | 説明 | Python/TSとの違い |
|-----|------|------------------|
| 所有権 | 値には所有者が1つだけ | GC言語では意識不要 |
| ムーブ | 代入で所有権が移動 | 参照のコピー（両方使える） |
| `&`（借用） | 不変参照を作成 | 明示的に書く必要がある |
| `&mut` | 可変借用（同時に1つだけ） | 制限なし（データ競合のリスク） |
| ライフタイム`'a` | 参照の有効期間 | GCが管理 |

🎯 **この章のポイント**:
- 所有権システムにより、**GCなしでメモリ安全を保証**
- `&`は「借用」、`&mut`は「可変借用」
- ライフタイムは「参照がどのくらい有効か」をコンパイラに伝える
- **コンパイラと対話** — エラーが出たらメッセージをよく読む
- 最初は戸惑うが、慣れると「バグが実行前に見つかる」安心感がある

---

## TypeScript/Pythonエンジニアのための移行コラム

### Pythonの参照カウントGCとの比較

Pythonは**参照カウント**を使ってメモリを管理しています。

```python
# Python: 参照カウントの仕組み
import sys

a = [1, 2, 3]           # refcount = 1
print(sys.getrefcount(a))  # 2（関数引数で一時的に+1）

b = a                   # refcount = 2
c = a                   # refcount = 3

del b                   # refcount = 2
del c                   # refcount = 1
del a                   # refcount = 0 → メモリ解放
```

**Pythonの問題**:
```python
# 循環参照 → 参照カウントだけでは解放できない
class Node:
    def __init__(self):
        self.next = None

a = Node()
b = Node()
a.next = b
b.next = a  # 循環参照！

del a
del b
# refcountは0にならない → 別のGC（世代別GC）が必要
```

**Rustの解決策**:
- 所有者は1つだけ → 循環参照が構造的に起きにくい
- 循環参照が必要な場合は`Rc<RefCell<T>>`や`Weak<T>`を使う

### よくあるコンパイルエラーと対処法

**エラー1: `value borrowed here after move`**

```
error[E0382]: borrow of moved value: `s`
```

原因: ムーブした後の値を使おうとした
対処: `clone()`するか、借用（`&`）を使う

```rust
// ❌ let s2 = s1; println!("{}", s1);
// ✅ let s2 = s1.clone(); println!("{}", s1);
// ✅ let s2 = &s1; println!("{}", s1);
```

**エラー2: `cannot borrow as mutable`**

```
error[E0596]: cannot borrow `s` as mutable, as it is not declared as mutable
```

原因: `mut`なしの変数を可変借用しようとした
対処: 変数宣言に`mut`を追加

```rust
// ❌ let s = String::from("hello"); s.push_str("!");
// ✅ let mut s = String::from("hello"); s.push_str("!");
```

**エラー3: `does not live long enough`**

```
error[E0597]: `x` does not live long enough
```

原因: 参照が参照先より長生きしようとしている
対処: ライフタイムを見直す、または所有権を渡す

---

## 次のステップ

[Chapter 03: 構造体・列挙型](03-structs-enums.md) では、Rustでデータを構造化する方法を学びます。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能です。所有権の知識を活かして、`self`と`&self`の使い分けを理解しましょう。
