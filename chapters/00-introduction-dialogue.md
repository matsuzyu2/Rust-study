# Chapter 00: 導入・環境構築

> **この章で学ぶこと**: Rustとは何か、なぜ学ぶ価値があるのか、開発環境の構築方法

---

## プロローグ：オフィスの休憩室にて

> 👩‍💻 **ユイ**: 「レイ先輩〜！ちょっといいですか？」
>
> 👩‍🏫 **レイ**: 「どうしたの、ユイちゃん。また何か作ろうとしてる？」
>
> 👩‍💻 **ユイ**: 「実は友達がSolanaでNFTプロジェクトやってるって聞いて、私も興味が出てきちゃって…。でも、Solanaって**Rust**で書くんですよね？私、PythonとReactしか知らないんですけど、Rustって難しそうで…」
>
> 👩‍🏫 **レイ**: 「あら、Web3に興味持ったんだ。いいじゃない！確かにSolanaはRustがメインだけど、Rustは別にWeb3専用ってわけじゃないわよ。実は最近、あらゆる分野で使われてる。」
>
> 👩‍💻 **ユイ**: 「そうなんですか？でも…難しいんですよね？メモリ管理とか、ポインタとか、聞いただけで頭痛くなりそうで…」
>
> 👩‍🏫 **レイ**: （クスッと笑って）「ユイちゃん、Rustのコンパイラは**厳しい先生じゃなくて、口うるさいけど優しいオカン**みたいなものよ。最初は『えーっ！？』って思うかもしれないけど、ちゃんと理由があって怒ってくれてるの。」
>
> 👩‍💻 **ユイ**: 「オカン…？（笑）それ、どういう意味ですか？」
>
> 👩‍🏫 **レイ**: 「実際に触ってみれば分かるわよ。まずは**なぜRustを学ぶ価値があるのか**から話そうか。コーヒー淹れてくる？」

---

## なぜRustを学ぶのか

> 👩‍🏫 **レイ**: 「じゃあ、ホワイトボード使うわね。ユイちゃんはPythonとTypeScriptで実務経験があるけど、Rustを学ぶとこんなメリットがあるの。」

（レイがホワイトボードにマーカーで書き始める）

### Rustが選ばれる3つの理由

> 👩‍🏫 **レイ**: 「**理由その1：パフォーマンス**」

#### 1. パフォーマンス

> 👩‍🏫 **レイ**: 「PythonやJavaScriptはインタプリタ言語でしょ？実行時にコードを解釈するから便利だけど、遅いのよね。Rustはコンパイル言語だから、ネイティブコードに直接変換されるの。」
>
> 👩‍💻 **ユイ**: 「ネイティブコード…？」
>
> 👩‍🏫 **レイ**: 「CPUが直接理解できる機械語のこと。だから実行速度が段違いに速いのよ。」

```
実行速度の目安（相対値）:
C/C++/Rust : 1x（最速）
Go/Java    : 2-5x
JavaScript : 10-50x
Python     : 50-100x
```

> 👩‍💻 **ユイ**: 「えっ、Pythonって**50〜100倍遅い**んですか！？」
>
> 👩‍🏫 **レイ**: 「まあ、処理内容にもよるけどね。でも、データ処理が重いバッチ処理とか、リアルタイム性が求められるAPIだと、この差は無視できないわ。」
>
> 👩‍💻 **ユイ**: 「確かに…。前にPythonでCSV処理したとき、10万行で10分くらいかかったことあります…。」
>
> 👩‍🏫 **レイ**: 「Rustで書き直せば、数秒で終わるかもね。」

#### 2. メモリ安全性（ガベージコレクタなし）

> 👩‍🏫 **レイ**: 「**理由その2：メモリ安全性**。これが一番の特徴かも。」
>
> 👩‍💻 **ユイ**: 「メモリ安全性…？」
>
> 👩‍🏫 **レイ**: 「PythonやJavaScriptって、メモリ管理を意識したことある？」
>
> 👩‍💻 **ユイ**: 「ないです！変数作ったら勝手に消えてくれるイメージです。」
>
> 👩‍🏫 **レイ**: 「それがガベージコレクタ（GC）の仕事よ。便利だけど、問題もあるの。GCが動くタイミングで、一瞬プログラムが**止まる**のよね。」
>
> 👩‍💻 **ユイ**: 「止まる…？」
>
> 👩‍🏫 **レイ**: 「うん。Stop-the-Worldって言うんだけど、GCがメモリを掃除してる間、プログラム全体が待たされるの。ゲームとかリアルタイムシステムだと致命的よね。」
>
> 👩‍💻 **ユイ**: 「えぇ…それは困りますね。じゃあRustは？」
>
> 👩‍🏫 **レイ**: 「Rustは**所有権システム**っていう仕組みで、**コンパイル時に**メモリの解放タイミングを決めるの。つまり：」

- **GCによる予期しない停止がない**
- **メモリリークが起きにくい**（使い終わったメモリは自動で解放される）
- **C/C++のようなバグもコンパイラが防ぐ**（ダングリングポインタ、二重解放など）

> 👩‍💻 **ユイ**: 「コンパイル時に決まるってすごい…！でも、所有権システムって難しそうですね…。」
>
> 👩‍🏫 **レイ**: 「最初はね。でも、一度理解すれば『なんでPythonにはこれがないの！？』ってなるわよ（笑）。Chapter 02で詳しくやるから安心して。」

#### 3. 実用的なユースケース

> 👩‍🏫 **レイ**: 「**理由その3：実用性**。Rustは理論だけじゃなくて、実際にめちゃくちゃ使われてるの。」

（レイがホワイトボードに表を書く）

| 分野 | なぜRust？ | 代表例 |
|-----|----------|-------|
| Web開発 | 高速なAPI、低レイテンシ | Axum, Actix-web |
| CLI開発 | シングルバイナリ配布、起動が速い | ripgrep, bat, exa |
| WebAssembly | ブラウザでネイティブ級の速度 | Figma, Cloudflare Workers |
| **Web3/ブロックチェーン** | **安全性とパフォーマンスが必須** | **Solana, Polkadot** |
| システム開発 | OS、ブラウザエンジン | Linux kernel, Firefox |

> 👩‍💻 **ユイ**: 「えっ、Firefoxって一部Rustなんですか！？」
>
> 👩‍🏫 **レイ**: 「そうよ。レンダリングエンジンの一部がRustで書き直されてるわ。それで速度とセキュリティが向上したの。」
>
> 👩‍💻 **ユイ**: 「すごい…。でも、Web3だとなんでRustなんですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね！Solanaみたいなブロックチェーンでは、**スマートコントラクトの実行コストが直接手数料に影響する**の。コードが遅いと、ユーザーが払う手数料が高くなるのよ。」
>
> 👩‍💻 **ユイ**: 「なるほど…！だからパフォーマンスが重要なんですね。」
>
> 👩‍🏫 **レイ**: 「そういうこと。それに、金融システムだから**バグがあったら大金が消える**わけ。だからメモリ安全性も絶対条件なの。」

---

## 開発ツールの比較

> 👩‍💻 **ユイ**: 「Rustって、開発環境はどうやって作るんですか？Pythonだとpyenv使ったり、Node.jsだとnvm使ったりしますけど…」
>
> 👩‍🏫 **レイ**: 「いい質問！実はRustの開発ツールは**めちゃくちゃ統一されてて便利**なのよ。比較表見せるわね。」

### パッケージマネージャ・ビルドツール

（レイがスマホで表を見せる）

| 役割 | Python | Node.js/TS | Rust |
|-----|--------|------------|------|
| 言語バージョン管理 | pyenv | nvm | **rustup** |
| パッケージマネージャ | pip | npm/yarn | **Cargo** |
| プロジェクト定義 | pyproject.toml | package.json | **Cargo.toml** |
| ロックファイル | requirements.txt / poetry.lock | package-lock.json | **Cargo.lock** |
| ビルド・実行 | python / pytest | npm run | **cargo build / cargo run** |
| フォーマッタ | black / ruff | prettier | **rustfmt** |
| リンター | ruff / pylint | eslint | **clippy** |

> 👩‍💻 **ユイ**: 「あれ？Cargoって、パッケージマネージャだけじゃないんですか？」
>
> 👩‍🏫 **レイ**: 「そうなのよ！Cargoは**パッケージマネージャ**、**ビルドツール**、**テストランナー**、**ドキュメント生成**を全部やってくれるの。いわば、npm + webpack + jest + typedoc を1つにまとめたようなものね。」
>
> 👩‍💻 **ユイ**: 「すごい…！それ、めっちゃ楽じゃないですか！」
>
> 👩‍🏫 **レイ**: 「でしょ？だから設定ファイル地獄に陥ることがないのよ。Rustの開発体験は本当に良くできてるわ。」

---

## 環境構築：一緒にやってみよう

> 👩‍🏫 **レイ**: 「じゃあ、実際に環境を作ってみましょうか。」
>
> 👩‍💻 **ユイ**: 「はい！お願いします！」

### Step 1: rustupのインストール

> 👩‍🏫 **レイ**: 「まず、rustupをインストールするわ。ターミナル開いて、このコマンド実行して。」

```bash
# macOS / Linux
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

> 👩‍💻 **ユイ**: 「おっ、なんか色々ダウンロードされてる…。」
>
> 👩‍🏫 **レイ**: 「rustupは、Rustのバージョンマネージャよ。pyenvやnvmと同じ役割ね。インストールが終わったら、シェルを再起動するか、このコマンド実行して。」

```bash
source $HOME/.cargo/env
```

> 👩‍💻 **ユイ**: 「これでいいんですか？」
>
> 👩‍🏫 **レイ**: 「バージョン確認してみて。」

```bash
rustc --version   # コンパイラ
cargo --version   # パッケージマネージャ/ビルドツール
```

> 👩‍💻 **ユイ**: 「出ました！`rustc 1.75.0`って表示されてます！」
>
> 👩‍🏫 **レイ**: 「完璧。ちなみに、最新版に更新するときはこのコマンドよ。」

```bash
rustup update
```

### Step 2: エディタの設定（VS Code）

> 👩‍🏫 **レイ**: 「次に、VS Codeの拡張機能を入れましょう。」
>
> 👩‍💻 **ユイ**: 「VS Code使ってます！何を入れればいいですか？」
>
> 👩‍🏫 **レイ**: 「これだけ入れておけば完璧よ。」

1. **rust-analyzer** — LSP（コード補完、エラー表示、リファクタリング）
2. **Even Better TOML** — Cargo.tomlのシンタックスハイライト
3. **CodeLLDB** — デバッガ（オプション）

> 👩‍💻 **ユイ**: 「rust-analyzerって、PylanceとかTypeScriptのtsserverみたいなやつですか？」
>
> 👩‍🏫 **レイ**: 「その通り！しかもrust-analyzerは**めちゃくちゃ優秀**で、型の推論結果をインラインで表示してくれるの。コンパイルエラーも即座に表示されるから、すごく快適よ。」
>
> 👩‍💻 **ユイ**: 「それは助かります！入れました！」

---

## 最初のプロジェクトを作る

> 👩‍🏫 **レイ**: 「じゃあ、最初のプロジェクトを作ってみましょう。」

### プロジェクトの作成

> 👩‍🏫 **レイ**: 「ターミナルでこのコマンド実行して。」

```bash
cargo new hello_rust
cd hello_rust
```

> 👩‍💻 **ユイ**: 「おおっ、一瞬でフォルダができました！」
>
> 👩‍🏫 **レイ**: 「そうでしょ？Pythonだと`mkdir`して`venv`作って…って面倒だったでしょ？」

#### 比較してみましょう

> 👩‍🏫 **レイ**: 「他の言語と比べてみると…」

```bash
# Python
mkdir project && cd project && python -m venv .venv

# Node.js
mkdir project && cd project && npm init -y

# Rust
cargo new project   # ← 一発で完了！
```

> 👩‍💻 **ユイ**: 「Rust、楽すぎません！？」

### プロジェクト構造

> 👩‍🏫 **レイ**: 「プロジェクトの中身を見てみて。」

```
hello_rust/
├── Cargo.toml    # package.json / pyproject.toml に相当
├── Cargo.lock    # 自動生成（コミット対象）
└── src/
    └── main.rs   # エントリーポイント
```

> 👩‍💻 **ユイ**: 「`Cargo.toml`が設定ファイルなんですね。中身はどうなってるんですか？」
>
> 👩‍🏫 **レイ**: 「開いてみて。」

**Cargo.toml の中身**:

```toml
[package]
name = "hello_rust"
version = "0.1.0"
edition = "2021"        # Rustのエディション（言語仕様のバージョン）

[dependencies]
# ここに依存クレート（ライブラリ）を追加
```

> 👩‍💻 **ユイ**: 「シンプルですね！`edition`って何ですか？」
>
> 👩‍🏫 **レイ**: 「Rustは後方互換性を保ちながら進化するために、3年ごとに**エディション**をリリースしてるの。2015、2018、2021…って感じ。でも、古いエディションのコードも動くから安心して。」

**src/main.rs の中身**:

```rust
fn main() {
    println!("Hello, world!");
}
```

> 👩‍💻 **ユイ**: 「おお、もうHello Worldが書かれてる！」
>
> 👩‍🏫 **レイ**: 「そう。`cargo new`すると、すぐに動くプロジェクトが作られるの。親切でしょ？」

### ビルドと実行

> 👩‍🏫 **レイ**: 「じゃあ実行してみましょう。」

```bash
cargo run
```

> 👩‍💻 **ユイ**: （実行してみる）「わぁ！`Hello, world!`って出ました！」
>
> 👩‍🏫 **レイ**: 「完璧。ちなみに、Cargoのコマンドはこんな感じよ。」

```bash
# コンパイル + 実行（開発用、最適化なし）
cargo run

# コンパイルのみ
cargo build

# リリースビルド（最適化あり、本番用）
cargo build --release

# テスト実行
cargo test

# コードフォーマット
cargo fmt

# 静的解析（リンター）
cargo clippy
```

> 👩‍💻 **ユイ**: 「これも比較するとどうなんですか？」
>
> 👩‍🏫 **レイ**: 「見てみて。」

#### 比較

```bash
# Python
python main.py          # 実行
pytest                  # テスト
black .                 # フォーマット
ruff check .            # リンター

# Node.js/TypeScript
npm run dev             # 実行
npm test                # テスト
npx prettier --write .  # フォーマット
npx eslint .            # リンター

# Rust（Cargoがすべて統一）
cargo run               # 実行
cargo test              # テスト
cargo fmt               # フォーマット
cargo clippy            # リンター
```

> 👩‍💻 **ユイ**: 「Rustって、ツール周りがめちゃくちゃ整ってますね…！」
>
> 👩‍🏫 **レイ**: 「でしょ？だからRustは**開発体験が良い**って言われるのよ。」

---

## 依存クレートの追加

> 👩‍💻 **ユイ**: 「あっ、外部ライブラリを使いたいときはどうすればいいんですか？」
>
> 👩‍🏫 **レイ**: 「Rustでは外部ライブラリを**クレート（crate）**って呼ぶの。追加は簡単よ。」

```bash
# 依存クレートを追加
cargo add serde          # npm install serde と同じ

# 開発時のみの依存
cargo add --dev tokio-test
```

> 👩‍💻 **ユイ**: 「あれ、`npm install`とほぼ同じじゃないですか！」
>
> 👩‍🏫 **レイ**: 「そうね。または`Cargo.toml`を直接編集してもOKよ。」

```toml
[dependencies]
serde = "1.0"
serde_json = "1.0"

[dev-dependencies]
tokio-test = "0.4"
```

> 👩‍💻 **ユイ**: 「クレートを探すときはどうするんですか？」
>
> 👩‍🏫 **レイ**: 「[crates.io](https://crates.io/) っていうサイトがあるわ。npmjs.comとかPyPIみたいなものね。」

---

## Hello, World! を理解する

> 👩‍🏫 **レイ**: 「さっきの`main.rs`、もう一度見てみましょうか。」

```rust
fn main() {
    println!("Hello, world!");
}
```

> 👩‍🏫 **レイ**: 「この短いコードにも、Rustの特徴が詰まってるのよ。」

| 要素 | 説明 | Python/TSとの違い |
|-----|------|------------------|
| `fn` | 関数定義キーワード | `def`（Python）、`function`（JS） |
| `main` | エントリーポイント（必須） | Pythonは `if __name__ == "__main__":`、Node.jsは任意 |
| `println!` | マクロ（`!`が目印） | 関数ではなくマクロ。コンパイル時に展開される |
| `;` | 文の終端（必須） | Pythonは不要、JSは省略可能 |

> 👩‍💻 **ユイ**: 「あれ、`println!`の最後に`!`がついてますね。これ何ですか？」
>
> 👩‍🏫 **レイ**: 「いいところに気づいたわね！この`!`は**マクロ**の印なの。」
>
> 👩‍💻 **ユイ**: 「マクロ…？」
>
> 👩‍🏫 **レイ**: 「Rustでは、関数とマクロを明確に区別するの。マクロは**コンパイル時にコードを生成する**強力な機能よ。`println!`は、実行時じゃなくてコンパイル時に、色々な処理を展開してくれるの。」
>
> 👩‍💻 **ユイ**: 「へぇ〜。TypeScriptのテンプレートリテラルみたいなものですか？」
>
> 👩‍🏫 **レイ**: 「もっと強力ね。マクロは後の章で詳しくやるから、今は『!がついてたらマクロ』って覚えておいて。」

---

## コンパイルエラーを恐れない

> 👩‍💻 **ユイ**: 「先輩、実は…Rustって**コンパイラが厳しい**って聞いて、ちょっと怖いんですけど…。」
>
> 👩‍🏫 **レイ**: 「あぁ、よく言われるわね（笑）。でも、実際に見てみましょう。わざとエラーを起こしてみるわ。」

```rust
fn main() {
    let x = 5;
    x = 10;  // ← これエラーになるわよ
}
```

> 👩‍💻 **ユイ**: 「えっ、何がダメなんですか？」
>
> 👩‍🏫 **レイ**: 「実行してみて。」

```
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:3:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     x = 10;
  |     ^^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++
```

> 👩‍💻 **ユイ**: 「うわぁ…なんか怒られた…。」
>
> 👩‍🏫 **レイ**: 「怒られたっていうか、**優しく教えてくれてる**のよ。見て、`help: consider making this binding mutable`って、解決策まで書いてくれてるでしょ？」
>
> 👩‍💻 **ユイ**: 「あっ、本当だ！`let mut x = 5;`にすればいいって書いてありますね！」
>
> 👩‍🏫 **レイ**: 「そう。Rustのコンパイラは**めちゃくちゃ親切**なの。何が問題で、どう直せばいいかまで教えてくれる。だから私は『口うるさいオカン』って呼んでるのよ（笑）。」
>
> 👩‍💻 **ユイ**: 「確かに…！Pythonだと、実行して初めてエラーに気づくことありますもんね。」
>
> 👩‍🏫 **レイ**: 「その通り！Rustは**実行前にバグを見つけてくれる**の。だから本番環境で予期しないエラーが起きにくいのよ。」
>
> 👩‍💻 **ユイ**: 「それは…すごく安心ですね。」
>
> 👩‍🏫 **レイ**: 「でしょ？だから、コンパイルエラーは**敵じゃなくて味方**なのよ。『コンパイラと対話しながらコードを書く』のがRust流よ。」

---

## まとめ

> 👩‍🏫 **レイ**: 「じゃあ、今日学んだことをまとめておくわね。」

| 項目 | 内容 |
|-----|------|
| Rustの強み | パフォーマンス、メモリ安全性、モダンなツールチェーン |
| rustup | Rustのバージョンマネージャ（pyenv/nvmに相当） |
| Cargo | パッケージマネージャ + ビルドツール + テストランナー |
| Cargo.toml | プロジェクト定義ファイル（package.json/pyproject.tomlに相当） |
| crates.io | クレート（ライブラリ）のレジストリ |
| rust-analyzer | VS Code拡張（LSP） |

> 👩‍💻 **ユイ**: 「思ったより簡単でした！`cargo run`だけで動くの、めっちゃ楽ですね！」
>
> 👩‍🏫 **レイ**: 「でしょ？Rustは『難しい』って先入観持たれがちだけど、実は**開発体験はすごく良い**のよ。」
>
> 👩‍💻 **ユイ**: 「これなら私にもできそうです！次は何を学ぶんですか？」
>
> 👩‍🏫 **レイ**: 「次は**型と変数**よ。TypeScriptの型システムと比較しながら解説するわね。特に、Rustの**イミュータブルデフォルト**っていう概念は、ユイちゃんにとって新鮮だと思うわよ。」
>
> 👩‍💻 **ユイ**: 「イミュータブル…デフォルト？」
>
> 👩‍🏫 **レイ**: 「お楽しみに。じゃあ、明日も頑張りましょう！」

---

## 次のステップ

[Chapter 01: 型と変数](01-basics-dialogue.md) では、Rustの型システムと変数について学びます。TypeScriptの型システムとの共通点・相違点を中心に、レイとユイの会話形式で解説します。
