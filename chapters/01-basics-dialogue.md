# Chapter 01: 型と変数

> **この章で学ぶこと**: Rustの型システム、変数宣言、イミュータブルとミュータブル、シャドーイング

---

## プロローグ：翌日のペアプログラミング

> 👩‍💻 **ユイ**: 「先輩、おはようございます！昨日環境作ったので、早速コード書いてみたんですけど…」
>
> 👩‍🏫 **レイ**: 「おはよう。おや、もう書き始めたの？やる気ね！どれどれ…」
>
> 👩‍💻 **ユイ**: 「これなんですけど…」

```rust
fn main() {
    let x = 5;
    x = 10;  // エラー！
    println!("x = {}", x);
}
```

> 👩‍💻 **ユイ**: 「コンパイルすると、`cannot assign twice to immutable variable`って怒られるんです…。Pythonなら普通に書ける処理なのに！なんか、私が悪いことしたみたいで怖いです…」
>
> 👩‍🏫 **レイ**: （クスッと笑って）「あぁ、やっぱりそこでつまずいたか。安心して、これは**Rust新人あるある第1位**よ。みんな最初に必ず通る道だから。」
>
> 👩‍💻 **ユイ**: 「えっ、みんなこれで怒られるんですか？」
>
> 👩‍🏫 **レイ**: 「そう。むしろ最初にこのエラーを踏んだのはラッキーよ。これがRustの**イミュータブルデフォルト**っていう設計思想の現れなの。」
>
> 👩‍💻 **ユイ**: 「イミュータブル…デフォルト…？」
>
> 👩‍🏫 **レイ**: 「うん。でもその前に、ちょっと歴史の話をさせて。なぜRustがこんなに『厳しく』見える設計になったのか、背景を知るとエラーメッセージへの見方が変わるから。」

---

## なぜRustは「厳しい」のか — 言語の生まれた背景

> 👩‍🏫 **レイ**: 「ユイちゃん、プログラミング言語って、どうやって生まれると思う？」
>
> 👩‍💻 **ユイ**: 「えっと…天才が『こんな言語あったらいいな』って思って作るんですか？」
>
> 👩‍🏫 **レイ**: 「半分正解。でも多くの場合、『既存の言語で死ぬほど苦労した経験』から生まれるのよ。Rustも例外じゃないわ。」
>
> 👩‍💻 **ユイ**: 「死ぬほど苦労…？」
>
> 👩‍🏫 **レイ**: 「そう。2006年頃、Mozilla（Firefox作ってる会社）のエンジニアだったGraydon Hoareって人が、自分の住んでるアパートのエレベーターがソフトウェアのバグで止まって閉じ込められたの。」
>
> 👩‍💻 **ユイ**: 「えぇ！？それは怖いですね…」
>
> 👩‍🏫 **レイ**: 「でしょ？そのエレベーターはC++で書かれてたらしいんだけど、彼は『こんなバグを起こす言語はおかしい。もっと安全な言語を作ろう』って思ったらしいの。」
>
> 👩‍💻 **ユイ**: 「エレベーターに閉じ込められたから新しい言語を作った…！スケールがすごい…」
>
> 👩‍🏫 **レイ**: 「これは有名なエピソードよ。ポイントは、**Rustは『人間のうっかりミス』を信頼していない**ってこと。プログラマを信頼しないんじゃなくて、**人間のミスはどうしても起きる**っていう前提で設計されてるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…だから変数がデフォルトで変更不可なんですね。『変更するつもりがないなら変更できないようにしておこう』って。」
>
> 👩‍🏫 **レイ**: 「そう！よく分かってきたじゃない。じゃあ本題に入りましょう。まずRustの型システムから。」

---

## Rustは静的型付け言語

> 👩‍🏫 **レイ**: 「Rustは**静的型付け言語**なの。すべての変数の型が、コンパイル時に決まるのよ。」
>
> 👩‍💻 **ユイ**: 「あっ、TypeScriptと同じですね！」
>
> 👩‍🏫 **レイ**: 「そう！ユイちゃんはTypeScript経験があるから、すぐ馴染めるはずよ。比較表見せるわね。」

| 言語 | 型システム | 型チェックのタイミング |
|-----|----------|---------------------|
| Python | 動的型付け（型ヒントはオプション） | 実行時 |
| TypeScript | 静的型付け（JavaScriptにトランスパイル） | コンパイル時 |
| Rust | 静的型付け（ネイティブコードにコンパイル） | コンパイル時 |

> 👩‍💻 **ユイ**: 「なるほど。じゃあTypeScriptと同じような感覚で書けるんですね！」
>
> 👩‍🏫 **レイ**: 「基本はね。でも、一つ大きな違いがあるの。TypeScriptは最終的にJavaScriptになるから、型を誤魔化す抜け道がいくらでもあるでしょ？`as any`とか、`@ts-ignore`とか。」
>
> 👩‍💻 **ユイ**: 「あぁ…前のプロジェクトで`any`だらけのコード見たことあります…。」
>
> 👩‍🏫 **レイ**: 「Rustにはそういう『抜け道』がほとんどないの。型システムを騙すには`unsafe`っていう明示的なキーワードを使う必要があって、コードレビューで一発で目立つようになってるわ。」
>
> 👩‍💻 **ユイ**: 「そこまで徹底してるんですね…！」
>
> 👩‍🏫 **レイ**: 「そう。**『安全でないコードを書くなら、そう宣言しろ』**っていうのがRustの哲学よ。」

---

## 変数宣言: `let`

> 👩‍🏫 **レイ**: 「Rustでは変数を`let`で宣言するわ。」

```rust
fn main() {
    let x = 5;           // 型推論: i32（32ビット整数）
    let y: i32 = 10;     // 明示的な型注釈
    let z: f64 = 3.14;   // 64ビット浮動小数点数

    println!("x = {}, y = {}, z = {}", x, y, z);
}
```

> 👩‍💻 **ユイ**: 「あれ、TypeScriptと似てますね！」
>
> 👩‍🏫 **レイ**: 「でしょ？比較してみましょう。」

#### 比較

```typescript
// TypeScript
let x = 5;           // 型推論: number
let y: number = 10;  // 明示的な型注釈
const z: number = 3.14;
```

```python
# Python（型ヒント）
x = 5           # 型推論なし（動的）
y: int = 10     # 型ヒント（実行時には無視）
z: float = 3.14
```

> 👩‍💻 **ユイ**: 「やっぱりTypeScriptと似てる…！これなら楽勝ですね！」
>
> 👩‍🏫 **レイ**: 「ちょっと待って。ここからが本番よ。」

---

## イミュータブルがデフォルト

> 👩‍🏫 **レイ**: 「さっきのエラー、もう一度見てみましょうか。」

```rust
fn main() {
    let x = 5;
    x = 10;  // ❌ コンパイルエラー！
}
```

> 👩‍🏫 **レイ**: 「Rustでは、`let`で宣言した変数は**デフォルトでイミュータブル（不変）**なの。」
>
> 👩‍💻 **ユイ**: 「えっ！？じゃあ、値を変更できないってことですか！？それって`const`と同じじゃ…」
>
> 👩‍🏫 **レイ**: 「いい質問！`const`とは違うのよ。後で説明するわ。変更したいなら、`mut`キーワードを付けるの。」

```rust
fn main() {
    let mut x = 5;  // mutableと明示
    x = 10;         // ✅ OK
    println!("x = {}", x);
}
```

> 👩‍💻 **ユイ**: 「`mut`…『ミュート』？静かにするってこと？」
>
> 👩‍🏫 **レイ**: 「違う違う（笑）。『ミュータブル（mutable）』の略よ。変更可能って意味。でも確かに紛らわしいわね。」
>
> 👩‍💻 **ユイ**: 「なんか、めんどくさくないですか？Pythonなら何も考えずに書けるのに…。いちいち『この変数は変更します！』って宣言するの？」
>
> 👩‍🏫 **レイ**: 「ユイちゃんの気持ちはわかるわ。でもね、これには深い理由があるの。ちょっと現場の話をさせて。」

### 現場でよくあるバグ

> 👩‍🏫 **レイ**: 「昨日、本番障害があったの覚えてる？」
>
> 👩‍💻 **ユイ**: 「あっ、決済金額がおかしくなったやつですか…？」
>
> 👩‍🏫 **レイ**: 「そう。原因はこういうコードだったの。」

```python
# Python（実際にあったバグ）
total = 0
for item in cart_items:
    total = total + item.price
    # ...中略（50行くらいの処理）...
    if item.is_discount:
        total = item.discounted_price  # ← バグ！totalを上書きしてる！
```

> 👩‍💻 **ユイ**: 「あっ…`+=`じゃなくて`=`になってる…。累計じゃなくて上書きしてますね…」
>
> 👩‍🏫 **レイ**: 「そう。50行も離れてるから気づきにくいのよ。レビューでも見落とした。でもRustなら…」

```rust
// Rust（イミュータブルなら安全）
let total = 0;  // mutがない
for item in cart_items {
    total = total + item.price;  // ❌ コンパイルエラー！
}
```

> 👩‍🏫 **レイ**: 「もし本当に変更する意図があるなら、最初から`let mut total`って書く。すると、『あ、この変数はどこかで書き換わるんだな』ってコードを読む人が分かるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…！`mut`がついてない変数は『絶対に変わらない』って保証されるんですね。」
>
> 👩‍🏫 **レイ**: 「そういうこと。これが**ドキュメントとしてのコード**って考え方よ。」

#### 比較

| 言語 | デフォルト | 不変にする | 可変にする |
|-----|----------|----------|----------|
| Python | 可変 | なし（慣習的に大文字） | デフォルト |
| TypeScript | 可変（`let`） | `const` | `let` |
| Rust | **不変（`let`）** | デフォルト | `let mut` |

> 👩‍💻 **ユイ**: 「Rustだけ逆なんですね…。なんでこんな設計にしたんですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね！さっきのバグの話にも繋がるけど、理由は3つあるわ。」

#### Rustがイミュータブルデフォルトを採用する理由

> 👩‍🏫 **レイ**: 「**理由その1：意図しない変更によるバグを防ぐ**」
>
> 👩‍🏫 **レイ**: 「さっきの決済バグがまさにそう。`mut`なしなら**絶対に書き換わらない**から、そういうバグが起きないのよ。」

> 👩‍🏫 **レイ**: 「**理由その2：並行処理の安全性**」
>
> 👩‍💻 **ユイ**: 「並行処理…？」
>
> 👩‍🏫 **レイ**: 「複数のスレッドで同時に処理する場合、可変な変数を共有すると**データ競合**が起きるの。でも、イミュータブルなら安全に共有できるわ。」
>
> 👩‍💻 **ユイ**: 「スレッド…まだよく分からないです…。」
>
> 👩‍🏫 **レイ**: 「今は『並行処理では不変データが重要』って覚えておいて。Chapter 08で詳しくやるから。」

> 👩‍🏫 **レイ**: 「**理由その3：コンパイラが最適化しやすい**」
>
> 👩‍🏫 **レイ**: 「変数が変わらないって分かれば、コンパイラが積極的に最適化できるのよ。だから実行速度が速くなるの。」

> 👩‍💻 **ユイ**: 「そっか…。最初は面倒だと思ったけど、ちゃんと意味があるんですね。」
>
> 👩‍🏫 **レイ**: 「現場の感覚で言うと、実際のコードで`mut`をつける変数は**全体の2〜3割くらい**よ。ほとんどの変数は一度代入したら変わらないの。」
>
> 👩‍💻 **ユイ**: 「えっ、そんなに少ないんですか？」
>
> 👩‍🏫 **レイ**: 「そう。だからRustは『例外的なケース（変更する）を明示させる』設計にしたの。これが**安全性とパフォーマンスを両立**する秘訣よ。」

### TypeScriptの`const`との違い

> 👩‍💻 **ユイ**: 「あれ、でもTypeScriptにも`const`ありますよね？あれとは違うんですか？」
>
> 👩‍🏫 **レイ**: 「鋭い！実は**全然違う**のよ。」

```typescript
// TypeScript
const arr = [1, 2, 3];
arr.push(4);     // ✅ OK（配列の中身は変更可能）
arr = [5, 6, 7]; // ❌ エラー（再代入は不可）
```

> 👩‍🏫 **レイ**: 「TypeScriptの`const`は**再代入不可**であって、**イミュータブル**ではないの。配列やオブジェクトの中身は変えられるわ。」
>
> 👩‍💻 **ユイ**: 「あっ、確かに…！`arr.push()`はできますもんね。」
>
> 👩‍🏫 **レイ**: 「でもRustの`let`は**本当に変更不可**なのよ。」

```rust
fn main() {
    let v = vec![1, 2, 3];  // Vec<i32>
    v.push(4);  // ❌ コンパイルエラー！

    let mut v = vec![1, 2, 3];
    v.push(4);  // ✅ OK
}
```

> 👩‍💻 **ユイ**: 「なるほど…！Rustの方が厳格なんですね。」
>
> 👩‍🏫 **レイ**: 「その通り。だから**バグが入り込む余地が少ない**の。」

---

## 基本的なデータ型

> 👩‍🏫 **レイ**: 「次は、Rustの基本的なデータ型を見ていきましょう。」

### 数値型

```rust
// 整数型（符号あり）
let a: i8 = 127;          // -128 〜 127
let b: i16 = 32_767;      // 16ビット
let c: i32 = 2_147_483_647;  // デフォルト
let d: i64 = 9_223_372_036_854_775_807;
let e: i128 = 170_141_183_460_469_231_731_687_303_715_884_105_727;
let f: isize = 100;       // ポインタサイズ（32bit/64bit環境依存）

// 整数型（符号なし）
let g: u8 = 255;          // 0 〜 255
let h: u32 = 4_294_967_295;
let i: usize = 100;       // 配列のインデックスに使う

// 浮動小数点数
let j: f32 = 3.14;        // 32ビット
let k: f64 = 3.14159265358979;  // デフォルト、64ビット
```

> 👩‍💻 **ユイ**: 「うわぁ…数値型、めっちゃ種類ありますね…！`i8`とか`u32`とか、何これ…？TypeScriptなら全部`number`で済むのに…」
>
> 👩‍🏫 **レイ**: 「`i`は**符号あり整数**（signed integer）、`u`は**符号なし整数**（unsigned integer）の略よ。数字はビット数ね。」
>
> 👩‍💻 **ユイ**: 「えっと、つまり`i32`は『符号あり32ビット整数』ってことですか？」
>
> 👩‍🏫 **レイ**: 「その通り！覚え方を教えるわね。」

```
i = integer（整数）+ signed（符号あり = マイナスもOK）
u = unsigned（符号なし = 0以上のみ）
数字 = ビット数（メモリ上で何ビット使うか）

i32 = 符号あり32ビット整数 = -21億 〜 +21億
u8  = 符号なし8ビット整数  = 0 〜 255
```

> 👩‍💻 **ユイ**: 「なるほど！でも、なんでこんなに細かく分けてるんですか？面倒じゃないですか？」

### なぜ数値型が細かく分かれているのか — ハードウェアの視点

> 👩‍🏫 **レイ**: 「これはRustの出自に関係するわ。Rustは**システムプログラミング言語**だから、ハードウェアに近い操作が必要なの。」
>
> 👩‍💻 **ユイ**: 「システムプログラミング…？」
>
> 👩‍🏫 **レイ**: 「OSやブラウザのエンジン、組み込みシステムみたいな、**ハードウェアに近い部分**を書く言語ってこと。例えば、組み込みシステムだとメモリが数キロバイトしかないこともあるわ。」
>
> 👩‍💻 **ユイ**: 「数キロバイト！？私のスマホのアプリより小さい…」
>
> 👩‍🏫 **レイ**: 「そうなの。そういう環境では、**1バイトでも無駄にできない**のよ。」

```
メモリ使用量の比較:
┌─────────────────────────────────────────┐
│ 型     │ サイズ │ 用途例                │
├─────────────────────────────────────────┤
│ u8     │ 1 byte │ RGBの色（0-255）      │
│ i16    │ 2 byte │ 音声サンプル          │
│ i32    │ 4 byte │ 一般的な整数          │
│ i64    │ 8 byte │ タイムスタンプ        │
│ f64    │ 8 byte │ 科学計算の精度が必要  │
└─────────────────────────────────────────┘

100万個の整数を扱う場合:
- u8:  1MB
- i32: 4MB
- i64: 8MB
→ 型を選ぶだけで8倍の差！
```

> 👩‍💻 **ユイ**: 「そんなに違うんですね…！」
>
> 👩‍🏫 **レイ**: 「あと、オーバーフローの検出もしやすくなるの。`u8`に256を入れようとするとコンパイル時にエラーになるわ。」
>
> 👩‍💻 **ユイ**: 「なるほど…でも、普段のWebアプリ開発ではそこまで気にしなくていいですか？」
>
> 👩‍🏫 **レイ**: 「正直、**ほとんどの場合は`i32`と`f64`で十分**よ。迷ったらデフォルトを使えばOK。ただ、配列のインデックスには`usize`を使うから、これは覚えておいて。」
>
> 👩‍💻 **ユイ**: 「`usize`…？」
>
> 👩‍🏫 **レイ**: 「32ビット環境なら32ビット、64ビット環境なら64ビットになる型よ。配列の長さとかインデックスに使うの。CPUのポインタサイズに合わせてるからね。」

> 👩‍🏫 **レイ**: 「ちなみに、数値リテラルでは`_`を区切りとして使えるのよ。」

```rust
let million = 1_000_000;  // 見やすい！
```

> 👩‍💻 **ユイ**: 「おお、これは便利ですね！」

### ブール型

```rust
let t: bool = true;
let f: bool = false;
```

> 👩‍💻 **ユイ**: 「これは普通ですね。」

### 文字型

```rust
let c: char = 'A';        // 4バイト（Unicodeスカラー値）
let emoji: char = '🦀';   // 絵文字もOK
```

> 👩‍💻 **ユイ**: 「カニの絵文字！可愛い！」
>
> 👩‍🏫 **レイ**: 「Rustのマスコットは**カニ（Ferris）**なのよ。だからRustacean（Rustユーザー）はカニ好きなの（笑）。」
>
> 👩‍💻 **ユイ**: 「へぇ〜！」
>
> 👩‍🏫 **レイ**: 「あと、注意点として、`char`は1文字を表して、**シングルクォート**を使うわ。文字列は**ダブルクォート**ね。」

```rust
let c: char = 'A';      // ✅ OK
let s: &str = "Hello";  // ✅ OK

let c: char = "A";      // ❌ エラー
```

---

## 文字列型：`&str`と`String`

> 👩‍💻 **ユイ**: 「文字列型って、TypeScriptみたいに`string`一つじゃないんですか？」
>
> 👩‍🏫 **レイ**: 「そう、ここが**Rust初心者最大の混乱ポイント**なのよね。Rustには**2つ**の文字列型があるの。」

```rust
// &str: 文字列スライス（不変、参照）
let s1: &str = "Hello";

// String: ヒープ上の可変文字列
let s2: String = String::from("Hello");
let s3: String = "Hello".to_string();  // 同じ意味
```

> 👩‍💻 **ユイ**: 「えっ、なんで2種類あるんですか…？意味わからないです…」
>
> 👩‍🏫 **レイ**: 「大丈夫、みんな最初は混乱するわ。これは**メモリ管理**に関わる話なの。Chapter 02で詳しくやるけど、今はこう覚えて。」

### 2つの文字列型 — 『所有』と『借用』の予告編

> 👩‍🏫 **レイ**: 「簡単に言うとこういうこと。」

| 型 | 何者？ | データの場所 | 変更 | 用途 |
|---|-------|------------|-----|-----|
| `&str` | 文字列の**参照**（借りてる） | プログラムのバイナリ内 or ヒープ | ❌ | 関数の引数、定数 |
| `String` | 文字列の**所有者** | ヒープ | ✅ | 動的に文字列を操作 |

> 👩‍💻 **ユイ**: 「借りてる…？所有者…？」
>
> 👩‍🏫 **レイ**: 「図書館をイメージして。」

```
📚 図書館のたとえ

&str = 図書館で本を「借りて読む」
     → 自分のものじゃないから書き込めない
     → いつか返す必要がある

String = 本を「買って自分のものにする」
       → 書き込み自由！
       → 使い終わったら自分で処分する
```

> 👩‍💻 **ユイ**: 「あぁ、なんとなくイメージできました！」
>
> 👩‍🏫 **レイ**: 「今は『文字列リテラル（`"..."`）は`&str`、動的に作るなら`String::from()`』って覚えておけばOKよ。所有権の章で詳しくやるから。」

### 実務でよく使うパターン

> 👩‍🏫 **レイ**: 「現場で一番よく見るのはこういうパターンよ。」

```rust
// 関数の引数は &str で受け取る（柔軟性が高い）
fn greet(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    greet("world");              // &str を渡せる
    
    let s = String::from("Rust");
    greet(&s);                   // String も & をつければ渡せる
}
```

> 👩‍💻 **ユイ**: 「関数の引数は`&str`にしておくと、両方受け取れるんですね！」
>
> 👩‍🏫 **レイ**: 「そう。これは**Rust流のベストプラクティス**よ。覚えておいて。」

#### 比較

```typescript
// TypeScript: string一種類のみ
const s: string = "Hello";
```

```python
# Python: str一種類（イミュータブル）
s = "Hello"
```

---

## タプルと配列

### タプル

> 👩‍🏫 **レイ**: 「タプルは、異なる型の値をまとめられるわ。」

```rust
fn main() {
    let tup: (i32, f64, &str) = (500, 6.4, "hello");

    // 分割代入（デストラクチャリング）
    let (x, y, z) = tup;
    println!("x = {}, y = {}, z = {}", x, y, z);

    // インデックスアクセス
    let first = tup.0;
    let second = tup.1;
}
```

> 👩‍💻 **ユイ**: 「あれ、これPythonとほぼ同じですね！」
>
> 👩‍🏫 **レイ**: 「そうね。TypeScriptとも似てるわ。」

#### 比較

```python
# Python
tup = (500, 6.4, "hello")
x, y, z = tup
first = tup[0]
```

```typescript
// TypeScript
const tup: [number, number, string] = [500, 6.4, "hello"];
const [x, y, z] = tup;
```

> 👩‍💻 **ユイ**: 「おお、TypeScriptは配列記法なんですね。Rustはタプル記法か…。」

### 配列

> 👩‍🏫 **レイ**: 「配列は**固定長**で**同じ型**の要素を持つわ。」

```rust
fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];  // 型: [要素型; 長さ]
    let first = arr[0];

    // 同じ値で初期化
    let zeros: [i32; 10] = [0; 10];  // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
}
```

> 👩‍💻 **ユイ**: 「えっ、**固定長**なんですか！？」
>
> 👩‍🏫 **レイ**: 「そう。Rustの配列は**コンパイル時に長さが決まる**のよ。だから`arr.push()`とかできないわ。」
>
> 👩‍💻 **ユイ**: 「えぇ…それ不便じゃないですか！？JavaScriptなら普通に`push`できるのに…。」
>
> 👩‍🏫 **レイ**: 「可変長が必要なら、`Vec<T>`（ベクタ）を使うのよ。これはChapter 06で詳しくやるわ。」

```rust
let mut v = vec![1, 2, 3];
v.push(4);  // ✅ OK
```

> 👩‍💻 **ユイ**: 「なんだ、ちゃんとあるんですね。びっくりした…。」

---

## シャドーイング

> 👩‍🏫 **レイ**: 「次は**シャドーイング**っていう面白い機能よ。」
>
> 👩‍💻 **ユイ**: 「シャドーイング…？影を作るってこと？」
>
> 👩‍🏫 **レイ**: 「そう、まさにそのイメージ。Rustでは、同じ名前で変数を**再宣言**できるの。前の変数に『影』がかかって見えなくなるイメージね。」

```rust
fn main() {
    let x = 5;
    let x = x + 1;      // 新しいxがシャドーイング
    let x = x * 2;      // さらにシャドーイング
    println!("x = {}", x);  // 12
}
```

> 👩‍💻 **ユイ**: 「えっ、同じ名前で何度も`let`してる！？しかも`mut`ついてないのに値が変わってる…？」
>
> 👩‍🏫 **レイ**: 「ここ大事よ。**値が変わってるんじゃない、新しい変数を作ってる**の。」
>
> 👩‍💻 **ユイ**: 「えっ、どういうことですか…？」

### シャドーイングとメモリ — 物理的に何が起きているか

> 👩‍🏫 **レイ**: 「ちょっとホワイトボード使うわね。スタックメモリの動きを見てみましょう。」

（レイがホワイトボードに描く）

```
┌─────────────────────────────────────────────────────────────────┐
│  シャドーイングのメモリ動作                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  let x = 5;                                                     │
│  ┌─────────────────┐                                            │
│  │ x: 5            │ ← アドレス 0x1000 に確保                    │
│  └─────────────────┘                                            │
│                                                                 │
│  let x = x + 1;                                                 │
│  ┌─────────────────┐                                            │
│  │ 古いx: 5        │ ← もう使えない（シャドーイングされた）        │
│  ├─────────────────┤                                            │
│  │ 新しいx: 6      │ ← アドレス 0x1004 に【新規に】確保           │
│  └─────────────────┘                                            │
│                                                                 │
│  let x = x * 2;                                                 │
│  ┌─────────────────┐                                            │
│  │ 古いx: 5        │ ← 使えない                                  │
│  ├─────────────────┤                                            │
│  │ 古いx: 6        │ ← 使えない                                  │
│  ├─────────────────┤                                            │
│  │ 新しいx: 12     │ ← アドレス 0x1008 に【新規に】確保           │
│  └─────────────────┘                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「あっ！毎回**新しいメモリ領域**に変数を作ってるんですね！」
>
> 👩‍🏫 **レイ**: 「そう！これが`mut`との決定的な違いよ。`mut`は**同じメモリ領域の値を書き換える**。シャドーイングは**新しいメモリ領域に新しい変数を作る**の。」

> 👩‍💻 **ユイ**: 「でも、それってメモリの無駄遣いじゃないですか…？」
>
> 👩‍🏫 **レイ**: 「いい質問！実は、コンパイラがちゃんと**最適化**してくれるの。使われなくなった変数のメモリは、スコープ内でも再利用されることがあるわ。実行時のパフォーマンスは`mut`とほぼ同じよ。」
>
> 👩‍💻 **ユイ**: 「コンパイラ、賢い…！」
>
> 👩‍🏫 **レイ**: 「そう。だから『メモリ効率のために`mut`を使う』みたいな心配はしなくていいの。**意味的に正しい方を選ぶ**ことが大事よ。」

### 型も変えられる — シャドーイングの真骨頂

> 👩‍🏫 **レイ**: 「しかも、シャドーイングは**型も変えられる**のよ。」

```rust
fn main() {
    let spaces = "   ";           // &str
    let spaces = spaces.len();    // usize（型が変わった！）
    println!("spaces = {}", spaces);  // 3
}
```

> 👩‍💻 **ユイ**: 「すごい…！`&str`から`usize`に変わってる！」
>
> 👩‍🏫 **レイ**: 「これは`mut`ではできないのよ。」

```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();  // ❌ コンパイルエラー！型が違う
}
```

> 👩‍💻 **ユイ**: 「あぁ、`mut`は同じ変数だから型が固定されるんですね。シャドーイングは新しい変数だから型も自由…なるほど！」
>
> 👩‍🏫 **レイ**: 「完璧！これ、**入力を受け取って変換する処理**でよく使うパターンよ。」

```rust
let input = "42";                        // &str（ユーザー入力）
let input: i32 = input.parse().unwrap(); // i32（パース後）
// 同じ「input」という名前で、文脈に合った型に
```

> 👩‍💻 **ユイ**: 「同じ変数名を使い回せるのは便利ですね！でも…これって使いすぎると読みにくくならないですか？」
>
> 👩‍🏫 **レイ**: 「鋭い！実務では**2〜3回まで**がベターよ。それ以上シャドーイングするなら、別の名前をつけた方が読みやすいわ。これは私のオピニオンだけどね。」

#### 比較

```typescript
// TypeScript: 同じスコープ内で再宣言はできない
let x = 5;
let x = 6;  // ❌ エラー: Cannot redeclare block-scoped variable 'x'
```

```python
# Python: 再代入は可能（動的型付けなので型も変わる）
x = 5
x = "hello"  # ✅ OK（でもmypyは警告する）
```

> 👩‍💻 **ユイ**: 「TypeScriptは再宣言できない、Pythonは再代入…Rustのシャドーイングはどっちとも違うんですね。」
>
> 👩‍🏫 **レイ**: 「そう。Rustだけの特徴的な機能ね。」

### `mut`とシャドーイングの違い — まとめ

> 👩‍🏫 **レイ**: 「この違いは絶対覚えて。」

| 特徴 | `let mut` | シャドーイング（`let`） |
|-----|----------|---------------------|
| メモリ | 同じ場所を書き換える | 新しい場所に確保 |
| 型の変更 | ❌ 不可 | ✅ 可能 |
| 意味 | 値の更新 | 新しい変数の作成 |
| 用途 | カウンタ、累積計算 | 型変換、データ加工 |

```rust
fn main() {
    // mutの例：カウンタとして使う（値が変わる）
    let mut count = 0;
    count += 1;  // 同じcountの値を更新
    count += 1;

    // シャドーイングの例：型変換（別の変数を作る）
    let input = "42";
    let input: i32 = input.parse().unwrap();
}
```

> 👩‍💻 **ユイ**: 「なるほど…！用途が違うんですね。」

---

## 型推論

> 👩‍🏫 **レイ**: 「Rustは強力な型推論を持ってるわ。多くの場合、型注釈を省略できるの。」

```rust
fn main() {
    let x = 5;           // i32と推論
    let y = 3.14;        // f64と推論
    let z = true;        // boolと推論

    let mut v = Vec::new();  // Vec<?>（まだ不明）
    v.push(1);               // ここでVec<i32>と確定
}
```

> 👩‍💻 **ユイ**: 「TypeScriptと同じですね！」
>
> 👩‍🏫 **レイ**: 「でも、推論できない場合は型注釈が**必須**よ。」

```rust
fn main() {
    let guess: i32 = "42".parse().expect("Not a number!");
    // parseはジェネリックなので、何型にパースするか指定が必要
}
```

> 👩‍💻 **ユイ**: 「なるほど。TypeScriptだと`any`になっちゃうけど、Rustは**必ず型が決まる**んですね。」
>
> 👩‍🏫 **レイ**: 「そう！Rustは曖昧さを許さないの。推論できなければコンパイルエラーよ。」

#### 比較

- **TypeScript**: 型推論が働くが、`any`にフォールバックすることがある
- **Rust**: **必ず型が決まる**。推論できなければコンパイルエラー

---

## 定数

> 👩‍🏫 **レイ**: 「最後に、`const`でコンパイル時定数を定義できるわ。」

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159265358979;

fn main() {
    println!("Max: {}, PI: {}", MAX_POINTS, PI);
}
```

> 👩‍💻 **ユイ**: 「`let`と何が違うんですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね。比較表見せるわ。」

### `let`と`const`の違い

| 特徴 | `let` | `const` |
|-----|-------|---------|
| 型注釈 | 省略可能 | **必須** |
| 値 | 実行時に計算可能 | **コンパイル時に確定** |
| スコープ | ブロック内 | グローバル可 |
| `mut` | 使用可能 | 使用不可 |

> 👩‍💻 **ユイ**: 「`const`は**コンパイル時に決まる**んですね。」
>
> 👩‍🏫 **レイ**: 「そう。だから関数の結果とかは代入できないわ。リテラルか定数式のみよ。」

---

## 型変換（キャスト）

> 👩‍🏫 **レイ**: 「最後に、型変換についてよ。Rustでは**暗黙の型変換がない**の。」
>
> 👩‍💻 **ユイ**: 「えっ、ないんですか！？」
>
> 👩‍🏫 **レイ**: 「ないわ。明示的に`as`を使うのよ。」

```rust
fn main() {
    let x: i32 = 10;
    let y: i64 = x as i64;  // 明示的にキャスト

    let f: f64 = 3.99;
    let i: i32 = f as i32;  // 切り捨て → 3
}
```

> 👩‍💻 **ユイ**: 「JavaScriptだと、勝手に変換されちゃいますよね…。」
>
> 👩‍🏫 **レイ**: 「そう。それがバグの温床なのよ。」

#### 比較

```javascript
// JavaScript: 暗黙の型変換（危険！）
const x = "5" + 3;  // "53"（文字列結合）
const y = "5" - 3;  // 2（数値計算）
```

> 👩‍💻 **ユイ**: 「これ、めっちゃややこしいですよね…！`+`と`-`で挙動が変わるの、何度もハマりました…。」
>
> 👩‍🏫 **レイ**: 「Rustならそういうバグは**絶対に起きない**わ。」

```rust
// Rust: 暗黙の型変換なし（安全！）
let x = "5" + 3;  // ❌ コンパイルエラー
```

> 👩‍💻 **ユイ**: 「最初は面倒だと思ったけど、これは安心ですね…！」

---

## まとめ

> 👩‍🏫 **レイ**: 「じゃあ、今日のまとめよ。」

| 概念 | Python/TS | Rust |
|-----|-----------|------|
| 変数宣言 | `let`/`const`、型ヒント | `let`（イミュータブル）、`let mut`（ミュータブル） |
| デフォルト | ミュータブル | **イミュータブル** |
| 型推論 | あり | あり（ただし曖昧なら必須） |
| 型変換 | 暗黙あり | **明示的（`as`）** |
| シャドーイング | なし/動的 | あり（型も変更可能、新しい変数を作成） |
| 文字列 | 1種類 | `&str`（参照）と`String`（所有） |

> 👩‍💻 **ユイ**: 「最初は『厳しすぎる！』って思ったけど、ちゃんと理由があるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。Rustは**バグが入り込む余地を減らす**ために、こういう設計にしてるの。」
>
> 👩‍💻 **ユイ**: 「エレベーターに閉じ込められた人が作った言語だから…」
>
> 👩‍🏫 **レイ**: 「そう（笑）。**『人間のうっかりミスを前提に設計する』**っていう哲学が根底にあるの。」
>
> 👩‍💻 **ユイ**: 「イミュータブルデフォルトも、最初は面倒だと思ったけど、慣れたら逆に**安心感がある**かもしれません。」
>
> 👩‍🏫 **レイ**: 「その調子！実は、Rustを書いてると**『変更するつもりがあるかどうか』を意識する**ようになるのよね。それがコードの質を上げるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…！」
>
> 👩‍🏫 **レイ**: 「ちなみに、今日やった内容は序の口よ。本当のRustらしさは次の章から始まるわ。」
>
> 👩‍💻 **ユイ**: 「所有権…！いよいよRustの本番ですね！」
>
> 👩‍🏫 **レイ**: 「そう。ここが一番の山場だけど、ユイちゃんなら大丈夫よ。今日シャドーイングのメモリの話をしたでしょ？所有権もあの延長線上にあるから、イメージしやすいはずよ。一緒に頑張りましょう！」
>
> 👩‍💻 **ユイ**: 「はい！楽しみです！」

---

## ポイント

- Rustは**「人間のうっかりミスを前提に」**設計された言語
- **イミュータブルデフォルト** — 変更するつもりなら`mut`と明示（全体の2〜3割程度）
- 型変換は常に**明示的** — バグの温床となる暗黙変換を排除
- **シャドーイングはmutと違う** — 新しい変数を作成（型も変更可能）
- 数値型が細かいのは**ハードウェアに近い制御**のため（迷ったら`i32`/`f64`）
- 文字列は`&str`（参照）と`String`（所有）の2種類 — 詳細は次章で

---

## 次のステップ

[Chapter 02: 所有権](02-ownership-dialogue.md) では、Rust最大の特徴である「所有権システム」を学びます。これはPython/TypeScriptには存在しない概念で、Rustを理解する上で最も重要なトピックです。レイとユイの会話を通じて、メモリの仕組みから丁寧に解説します。
