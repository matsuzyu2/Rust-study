# Chapter 01: 型と変数

> **この章で学ぶこと**: Rustの型システム、変数宣言、イミュータブルとミュータブル、シャドーイング

---

## プロローグ：翌日のペアプログラミング

> 👩‍💻 **ユイ**: 「先輩、おはようございます！昨日環境作ったので、早速コード書いてみたんですけど…」
>
> 👩‍🏫 **レイ**: 「おはよう。おや、もう書き始めたの？やる気ね！どれどれ…」
>
> 👩‍💻 **ユイ**: 「これなんですけど…」

```rust
fn main() {
    let x = 5;
    x = 10;  // エラー！
    println!("x = {}", x);
}
```

> 👩‍💻 **ユイ**: 「コンパイルすると、`cannot assign twice to immutable variable`って怒られるんです…。Pythonなら普通に書ける処理なのに！」
>
> 👩‍🏫 **レイ**: （クスッと笑って）「あぁ、やっぱりそこでつまずいたか。これがRustの**イミュータブルデフォルト**よ。」
>
> 👩‍💻 **ユイ**: 「イミュータブル…デフォルト…？」
>
> 👩‍🏫 **レイ**: 「順番に説明するわね。まず、Rustの型システムから理解しましょう。」

---

## Rustは静的型付け言語

> 👩‍🏫 **レイ**: 「Rustは**静的型付け言語**なの。すべての変数の型が、コンパイル時に決まるのよ。」
>
> 👩‍💻 **ユイ**: 「あっ、TypeScriptと同じですね！」
>
> 👩‍🏫 **レイ**: 「そう！ユイちゃんはTypeScript経験があるから、すぐ馴染めるはずよ。比較表見せるわね。」

| 言語 | 型システム | 型チェックのタイミング |
|-----|----------|---------------------|
| Python | 動的型付け（型ヒントはオプション） | 実行時 |
| TypeScript | 静的型付け（JavaScriptにトランスパイル） | コンパイル時 |
| Rust | 静的型付け（ネイティブコードにコンパイル） | コンパイル時 |

> 👩‍💻 **ユイ**: 「なるほど。じゃあTypeScriptと同じような感覚で書けるんですね！」
>
> 👩‍🏫 **レイ**: 「基本はね。でも、いくつか重要な違いがあるの。それが…」

---

## 変数宣言: `let`

> 👩‍🏫 **レイ**: 「Rustでは変数を`let`で宣言するわ。」

```rust
fn main() {
    let x = 5;           // 型推論: i32（32ビット整数）
    let y: i32 = 10;     // 明示的な型注釈
    let z: f64 = 3.14;   // 64ビット浮動小数点数

    println!("x = {}, y = {}, z = {}", x, y, z);
}
```

> 👩‍💻 **ユイ**: 「あれ、TypeScriptと似てますね！」
>
> 👩‍🏫 **レイ**: 「でしょ？比較してみましょう。」

#### 比較

```typescript
// TypeScript
let x = 5;           // 型推論: number
let y: number = 10;  // 明示的な型注釈
const z: number = 3.14;
```

```python
# Python（型ヒント）
x = 5           # 型推論なし（動的）
y: int = 10     # 型ヒント（実行時には無視）
z: float = 3.14
```

> 👩‍💻 **ユイ**: 「やっぱりTypeScriptと似てる…！これなら楽勝ですね！」
>
> 👩‍🏫 **レイ**: 「ちょっと待って。ここからが本番よ。」

---

## イミュータブルがデフォルト

> 👩‍🏫 **レイ**: 「さっきのエラー、もう一度見てみましょうか。」

```rust
fn main() {
    let x = 5;
    x = 10;  // ❌ コンパイルエラー！
}
```

> 👩‍🏫 **レイ**: 「Rustでは、`let`で宣言した変数は**デフォルトでイミュータブル（不変）**なの。」
>
> 👩‍💻 **ユイ**: 「えっ！？じゃあ、値を変更できないってことですか！？」
>
> 👩‍🏫 **レイ**: 「そう。変更したいなら、`mut`キーワードを付けるのよ。」

```rust
fn main() {
    let mut x = 5;  // mutableと明示
    x = 10;         // ✅ OK
    println!("x = {}", x);
}
```

> 👩‍💻 **ユイ**: 「むっと…？なんか、めんどくさくないですか？Pythonなら何も考えずに書けるのに…。」
>
> 👩‍🏫 **レイ**: 「ユイちゃんの気持ちはわかるわ。でもね、これには深い理由があるの。比較表見てみて。」

#### 比較

| 言語 | デフォルト | 不変にする | 可変にする |
|-----|----------|----------|----------|
| Python | 可変 | なし（慣習的に大文字） | デフォルト |
| TypeScript | 可変（`let`） | `const` | `let` |
| Rust | **不変（`let`）** | デフォルト | `let mut` |

> 👩‍💻 **ユイ**: 「Rustだけ逆なんですね…。なんでこんな設計にしたんですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね！Rustが**イミュータブルデフォルト**を採用してる理由は3つあるわ。」

#### Rustがイミュータブルデフォルトを採用する理由

> 👩‍🏫 **レイ**: 「**理由その1：バグを防ぐ**」
>
> 👩‍🏫 **レイ**: 「例えば、こんなコードがあったとして…」

```python
# Python（バグの温床）
total = 0
for item in items:
    total = total + item.price  # ← 意図的な変更
    # ...100行くらいコード...
    total = 0  # ← うっかりリセット！バグ！
```

> 👩‍🏫 **レイ**: 「変数が勝手に書き換わってるのに気づかず、バグになることってあるでしょ？」
>
> 👩‍💻 **ユイ**: 「あります…！前にループの中で変数を上書きしちゃって、デバッグに2時間かかりました…。」
>
> 👩‍🏫 **レイ**: 「Rustだと、`mut`をつけてない限り**絶対に書き換わらない**から、そういうバグが起きないのよ。」

> 👩‍🏫 **レイ**: 「**理由その2：並行処理の安全性**」
>
> 👩‍💻 **ユイ**: 「並行処理…？」
>
> 👩‍🏫 **レイ**: 「複数のスレッドで同時に処理する場合、可変な変数を共有すると**データ競合**が起きるの。でも、イミュータブルなら安全に共有できるわ。」
>
> 👩‍💻 **ユイ**: 「なるほど…。まだピンとこないですけど、大事そうですね。」
>
> 👩‍🏫 **レイ**: 「後の章でやるから楽しみにしててね。」

> 👩‍🏫 **レイ**: 「**理由その3：コンパイラが最適化しやすい**」
>
> 👩‍🏫 **レイ**: 「変数が変わらないって分かれば、コンパイラが積極的に最適化できるのよ。だから実行速度が速くなるの。」

> 👩‍💻 **ユイ**: 「そっか…。最初は面倒だと思ったけど、ちゃんと意味があるんですね。」
>
> 👩‍🏫 **レイ**: 「でしょ？Rustは**安全性とパフォーマンスを両立**するために、こういう設計にしてるのよ。」

### TypeScriptの`const`との違い

> 👩‍💻 **ユイ**: 「あれ、でもTypeScriptにも`const`ありますよね？あれとは違うんですか？」
>
> 👩‍🏫 **レイ**: 「鋭い！実は**全然違う**のよ。」

```typescript
// TypeScript
const arr = [1, 2, 3];
arr.push(4);     // ✅ OK（配列の中身は変更可能）
arr = [5, 6, 7]; // ❌ エラー（再代入は不可）
```

> 👩‍🏫 **レイ**: 「TypeScriptの`const`は**再代入不可**であって、**イミュータブル**ではないの。配列やオブジェクトの中身は変えられるわ。」
>
> 👩‍💻 **ユイ**: 「あっ、確かに…！`arr.push()`はできますもんね。」
>
> 👩‍🏫 **レイ**: 「でもRustの`let`は**本当に変更不可**なのよ。」

```rust
fn main() {
    let v = vec![1, 2, 3];  // Vec<i32>
    v.push(4);  // ❌ コンパイルエラー！

    let mut v = vec![1, 2, 3];
    v.push(4);  // ✅ OK
}
```

> 👩‍💻 **ユイ**: 「なるほど…！Rustの方が厳格なんですね。」
>
> 👩‍🏫 **レイ**: 「その通り。だから**バグが入り込む余地が少ない**の。」

---

## 基本的なデータ型

> 👩‍🏫 **レイ**: 「次は、Rustの基本的なデータ型を見ていきましょう。」

### 数値型

```rust
// 整数型（符号あり）
let a: i8 = 127;          // -128 〜 127
let b: i16 = 32_767;      // 16ビット
let c: i32 = 2_147_483_647;  // デフォルト
let d: i64 = 9_223_372_036_854_775_807;
let e: i128 = 170_141_183_460_469_231_731_687_303_715_884_105_727;
let f: isize = 100;       // ポインタサイズ（32bit/64bit環境依存）

// 整数型（符号なし）
let g: u8 = 255;          // 0 〜 255
let h: u32 = 4_294_967_295;
let i: usize = 100;       // 配列のインデックスに使う

// 浮動小数点数
let j: f32 = 3.14;        // 32ビット
let k: f64 = 3.14159265358979;  // デフォルト、64ビット
```

> 👩‍💻 **ユイ**: 「うわぁ…数値型、めっちゃ種類ありますね…！`i8`とか`u32`とか、何これ…？」
>
> 👩‍🏫 **レイ**: 「`i`は**符号あり整数**（signed integer）、`u`は**符号なし整数**（unsigned integer）の略よ。数字はビット数ね。」
>
> 👩‍💻 **ユイ**: 「TypeScriptなら全部`number`で済むのに…。」
>
> 👩‍🏫 **レイ**: 「そうね。比較してみましょう。」

#### 比較

- **Python**: `int`（任意精度）、`float`（64ビット）
- **TypeScript**: `number`（64ビット浮動小数点数のみ）、`bigint`
- **Rust**: サイズ別に多数の型（**メモリ効率を細かく制御可能**）

> 👩‍💻 **ユイ**: 「なんでこんなに細かく分けてるんですか？」
>
> 👩‍🏫 **レイ**: 「メモリ効率とパフォーマンスのためよ。例えば、0〜255しか扱わないなら`u8`で1バイトしか使わない。でも`i32`なら4バイト使うわ。」
>
> 👩‍💻 **ユイ**: 「あぁ、そういうことか…！組み込みシステムとかだと、メモリが限られてますもんね。」
>
> 👩‍🏫 **レイ**: 「その通り。それに、型を明示することで**オーバーフローのバグも防げる**の。」

> 👩‍🏫 **レイ**: 「ちなみに、数値リテラルでは`_`を区切りとして使えるのよ。」

```rust
let million = 1_000_000;  // 見やすい！
```

> 👩‍💻 **ユイ**: 「おお、これは便利ですね！」

### ブール型

```rust
let t: bool = true;
let f: bool = false;
```

> 👩‍💻 **ユイ**: 「これは普通ですね。」

### 文字型

```rust
let c: char = 'A';        // 4バイト（Unicodeスカラー値）
let emoji: char = '🦀';   // 絵文字もOK
```

> 👩‍💻 **ユイ**: 「カニの絵文字！可愛い！」
>
> 👩‍🏫 **レイ**: 「Rustのマスコットは**カニ（Ferris）**なのよ。だからRustacean（Rustユーザー）はカニ好きなの（笑）。」
>
> 👩‍💻 **ユイ**: 「へぇ〜！」
>
> 👩‍🏫 **レイ**: 「あと、注意点として、`char`は1文字を表して、**シングルクォート**を使うわ。文字列は**ダブルクォート**ね。」

```rust
let c: char = 'A';      // ✅ OK
let s: &str = "Hello";  // ✅ OK

let c: char = "A";      // ❌ エラー
```

---

## 文字列型：`&str`と`String`

> 👩‍💻 **ユイ**: 「文字列型って、TypeScriptみたいに`string`一つじゃないんですか？」
>
> 👩‍🏫 **レイ**: 「そう、ここが**Rustの罠**なのよね。Rustには**2つ**の文字列型があるの。」

```rust
// &str: 文字列スライス（不変、スタック上の参照）
let s1: &str = "Hello";

// String: ヒープ上の可変文字列
let s2: String = String::from("Hello");
let s3: String = "Hello".to_string();  // 同じ意味
```

> 👩‍💻 **ユイ**: 「えっ、なんで2種類あるんですか…？」
>
> 👩‍🏫 **レイ**: 「これは**メモリ管理**に関わる話なの。詳しくはChapter 02の所有権で解説するけど、簡単に言うと…」

- **`&str`**: 文字列の**借用**（どこかにある文字列への参照）
- **`String`**: 文字列の**所有**（ヒープに確保されたデータ）

> 👩‍💻 **ユイ**: 「うーん、まだピンとこないです…。」
>
> 👩‍🏫 **レイ**: 「大丈夫、今は『文字列リテラル（`"..."`）は`&str`、`String::from()`で`String`を作る』って覚えておけばOKよ。」
>
> 👩‍💻 **ユイ**: 「わかりました！」

#### 比較

```typescript
// TypeScript: string一種類のみ
const s: string = "Hello";
```

```python
# Python: str一種類（イミュータブル）
s = "Hello"
```

---

## タプルと配列

### タプル

> 👩‍🏫 **レイ**: 「タプルは、異なる型の値をまとめられるわ。」

```rust
fn main() {
    let tup: (i32, f64, &str) = (500, 6.4, "hello");

    // 分割代入（デストラクチャリング）
    let (x, y, z) = tup;
    println!("x = {}, y = {}, z = {}", x, y, z);

    // インデックスアクセス
    let first = tup.0;
    let second = tup.1;
}
```

> 👩‍💻 **ユイ**: 「あれ、これPythonとほぼ同じですね！」
>
> 👩‍🏫 **レイ**: 「そうね。TypeScriptとも似てるわ。」

#### 比較

```python
# Python
tup = (500, 6.4, "hello")
x, y, z = tup
first = tup[0]
```

```typescript
// TypeScript
const tup: [number, number, string] = [500, 6.4, "hello"];
const [x, y, z] = tup;
```

> 👩‍💻 **ユイ**: 「おお、TypeScriptは配列記法なんですね。Rustはタプル記法か…。」

### 配列

> 👩‍🏫 **レイ**: 「配列は**固定長**で**同じ型**の要素を持つわ。」

```rust
fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];  // 型: [要素型; 長さ]
    let first = arr[0];

    // 同じ値で初期化
    let zeros: [i32; 10] = [0; 10];  // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
}
```

> 👩‍💻 **ユイ**: 「えっ、**固定長**なんですか！？」
>
> 👩‍🏫 **レイ**: 「そう。Rustの配列は**コンパイル時に長さが決まる**のよ。だから`arr.push()`とかできないわ。」
>
> 👩‍💻 **ユイ**: 「えぇ…それ不便じゃないですか！？JavaScriptなら普通に`push`できるのに…。」
>
> 👩‍🏫 **レイ**: 「可変長が必要なら、`Vec<T>`（ベクタ）を使うのよ。これはChapter 06で詳しくやるわ。」

```rust
let mut v = vec![1, 2, 3];
v.push(4);  // ✅ OK
```

> 👩‍💻 **ユイ**: 「なんだ、ちゃんとあるんですね。びっくりした…。」

---

## シャドーイング

> 👩‍🏫 **レイ**: 「次は**シャドーイング**っていう面白い機能よ。」
>
> 👩‍💻 **ユイ**: 「シャドーイング…？」
>
> 👩‍🏫 **レイ**: 「Rustでは、同じ名前で変数を**再宣言**できるの。」

```rust
fn main() {
    let x = 5;
    let x = x + 1;      // 新しいxがシャドーイング
    let x = x * 2;      // さらにシャドーイング
    println!("x = {}", x);  // 12
}
```

> 👩‍💻 **ユイ**: 「えっ、同じ名前で何度も`let`してる！？」
>
> 👩‍🏫 **レイ**: 「そう。しかも、**型も変えられる**のよ。」

```rust
fn main() {
    let spaces = "   ";           // &str
    let spaces = spaces.len();    // usize（型が変わった！）
}
```

> 👩‍💻 **ユイ**: 「すごい…！これ、TypeScriptではできないですよね？」
>
> 👩‍🏫 **レイ**: 「できないわ。」

#### 比較

```typescript
// TypeScript: 同じスコープ内で再宣言はできない
let x = 5;
let x = 6;  // ❌ エラー
```

```python
# Python: 再代入は可能（動的型付けなので型も変わる）
x = 5
x = "hello"  # ✅ OK（でも型チェッカーは警告する）
```

> 👩‍💻 **ユイ**: 「なんでこんなことができるんですか？」
>
> 👩‍🏫 **レイ**: 「シャドーイングは`mut`とは違うのよ。」

### `mut`とシャドーイングの違い

> 👩‍🏫 **レイ**: 「ポイントはこれよ。」

- **`mut`**: 同じ変数の**値を変更**
- **シャドーイング**: **新しい変数を作成**（以前の変数は隠れる）

```rust
fn main() {
    // mutの例
    let mut x = 5;
    x = 10;        // 値を変更（同じ変数）

    // シャドーイングの例
    let x = 5;
    let x = "hello";  // 新しい変数（型も変えられる）
}
```

> 👩‍💻 **ユイ**: 「なるほど…！シャドーイングは『新しい変数』だから、型も変えられるんですね。」
>
> 👩‍🏫 **レイ**: 「その通り！例えば、入力を受け取って変換する処理でよく使うわ。」

```rust
let input = "42";               // &str
let input: i32 = input.parse().unwrap();  // i32
```

> 👩‍💻 **ユイ**: 「同じ変数名を使い回せるのは便利ですね！」

---

## 型推論

> 👩‍🏫 **レイ**: 「Rustは強力な型推論を持ってるわ。多くの場合、型注釈を省略できるの。」

```rust
fn main() {
    let x = 5;           // i32と推論
    let y = 3.14;        // f64と推論
    let z = true;        // boolと推論

    let mut v = Vec::new();  // Vec<?>（まだ不明）
    v.push(1);               // ここでVec<i32>と確定
}
```

> 👩‍💻 **ユイ**: 「TypeScriptと同じですね！」
>
> 👩‍🏫 **レイ**: 「でも、推論できない場合は型注釈が**必須**よ。」

```rust
fn main() {
    let guess: i32 = "42".parse().expect("Not a number!");
    // parseはジェネリックなので、何型にパースするか指定が必要
}
```

> 👩‍💻 **ユイ**: 「なるほど。TypeScriptだと`any`になっちゃうけど、Rustは**必ず型が決まる**んですね。」
>
> 👩‍🏫 **レイ**: 「そう！Rustは曖昧さを許さないの。推論できなければコンパイルエラーよ。」

#### 比較

- **TypeScript**: 型推論が働くが、`any`にフォールバックすることがある
- **Rust**: **必ず型が決まる**。推論できなければコンパイルエラー

---

## 定数

> 👩‍🏫 **レイ**: 「最後に、`const`でコンパイル時定数を定義できるわ。」

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159265358979;

fn main() {
    println!("Max: {}, PI: {}", MAX_POINTS, PI);
}
```

> 👩‍💻 **ユイ**: 「`let`と何が違うんですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね。比較表見せるわ。」

### `let`と`const`の違い

| 特徴 | `let` | `const` |
|-----|-------|---------|
| 型注釈 | 省略可能 | **必須** |
| 値 | 実行時に計算可能 | **コンパイル時に確定** |
| スコープ | ブロック内 | グローバル可 |
| `mut` | 使用可能 | 使用不可 |

> 👩‍💻 **ユイ**: 「`const`は**コンパイル時に決まる**んですね。」
>
> 👩‍🏫 **レイ**: 「そう。だから関数の結果とかは代入できないわ。リテラルか定数式のみよ。」

---

## 型変換（キャスト）

> 👩‍🏫 **レイ**: 「最後に、型変換についてよ。Rustでは**暗黙の型変換がない**の。」
>
> 👩‍💻 **ユイ**: 「えっ、ないんですか！？」
>
> 👩‍🏫 **レイ**: 「ないわ。明示的に`as`を使うのよ。」

```rust
fn main() {
    let x: i32 = 10;
    let y: i64 = x as i64;  // 明示的にキャスト

    let f: f64 = 3.99;
    let i: i32 = f as i32;  // 切り捨て → 3
}
```

> 👩‍💻 **ユイ**: 「JavaScriptだと、勝手に変換されちゃいますよね…。」
>
> 👩‍🏫 **レイ**: 「そう。それがバグの温床なのよ。」

#### 比較

```javascript
// JavaScript: 暗黙の型変換（危険！）
const x = "5" + 3;  // "53"（文字列結合）
const y = "5" - 3;  // 2（数値計算）
```

> 👩‍💻 **ユイ**: 「これ、めっちゃややこしいですよね…！`+`と`-`で挙動が変わるの、何度もハマりました…。」
>
> 👩‍🏫 **レイ**: 「Rustならそういうバグは**絶対に起きない**わ。」

```rust
// Rust: 暗黙の型変換なし（安全！）
let x = "5" + 3;  // ❌ コンパイルエラー
```

> 👩‍💻 **ユイ**: 「最初は面倒だと思ったけど、これは安心ですね…！」

---

## まとめ

> 👩‍🏫 **レイ**: 「じゃあ、今日のまとめよ。」

| 概念 | Python/TS | Rust |
|-----|-----------|------|
| 変数宣言 | `let`/`const`、型ヒント | `let`（イミュータブル）、`let mut`（ミュータブル） |
| デフォルト | ミュータブル | **イミュータブル** |
| 型推論 | あり | あり（ただし曖昧なら必須） |
| 型変換 | 暗黙あり | **明示的（`as`）** |
| シャドーイング | なし/動的 | あり（型も変更可能） |
| 文字列 | 1種類 | `&str`（スライス）と`String`（ヒープ） |

> 👩‍💻 **ユイ**: 「最初は『厳しすぎる！』って思ったけど、ちゃんと理由があるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。Rustは**バグが入り込む余地を減らす**ために、こういう設計にしてるの。」
>
> 👩‍💻 **ユイ**: 「イミュータブルデフォルトも、最初は面倒だと思ったけど、慣れたら逆に**安心感がある**かもしれません。」
>
> 👩‍🏫 **レイ**: 「その調子！実は、Rustを書いてると**『変更するつもりがあるかどうか』を意識する**ようになるのよね。それがコードの質を上げるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…！」
>
> 👩‍🏫 **レイ**: 「じゃあ、次はいよいよ**所有権システム**よ。」
>
> 👩‍💻 **ユイ**: 「所有権…！いよいよRustの本番ですね！」
>
> 👩‍🏫 **レイ**: 「そう。ここが一番の山場だけど、ユイちゃんなら大丈夫よ。一緒に頑張りましょう！」

---

## ポイント

- Rustは**イミュータブルデフォルト** — 変更するつもりなら`mut`と明示
- 型変換は常に**明示的** — バグの温床となる暗黙変換を排除
- コンパイラが型を推論できなければ**エラー** — 曖昧さを許さない
- シャドーイングで**型も変更可能** — TypeScriptにはない機能

---

## 次のステップ

[Chapter 02: 所有権](02-ownership-dialogue.md) では、Rust最大の特徴である「所有権システム」を学びます。これはPython/TypeScriptには存在しない概念で、Rustを理解する上で最も重要なトピックです。レイとユイの会話を通じて、メモリの仕組みから丁寧に解説します。
