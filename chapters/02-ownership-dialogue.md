# Chapter 02: 所有権

> **この章で学ぶこと**: 所有権、借用（`&`と`&mut`）、ライフタイム — Rust最大の特徴にして最重要概念

> 📖 **記号リファレンス**: この章では `&`, `&mut`, `'a` など重要な記号が登場します。意味がわからなくなったら [Chapter 11: 記号・構文リファレンス](11-syntax-reference.md) を参照してください。

---

## プロローグ：所有権との遭遇

> 👩‍💻 **ユイ**: 「先輩！また怒られました！！」
>
> 👩‍🏫 **レイ**: 「落ち着いて。何のエラー？」
>
> 👩‍💻 **ユイ**: 「これです…」

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);  // ❌ エラー！
}
```

```
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:20
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
```

> 👩‍💻 **ユイ**: 「『value moved here』って何ですか！？`s2 = s1`って普通の代入じゃないんですか！？Pythonなら両方使えるのに…！」
>
> 👩‍🏫 **レイ**: （深く息を吐いて）「よし…来たわね。いよいよRustの本丸、**所有権システム**よ。」
>
> 👩‍💻 **ユイ**: 「所有権…！」
>
> 👩‍🏫 **レイ**: 「これはRust最大の特徴にして、最も理解しづらいところ。でも、一度理解すれば『なんでPythonにこれがないの！？』ってなるわよ。ホワイトボード使って、ゼロから説明するわね。」

---

## なぜ所有権が必要なのか — 本当の理由

> 👩‍🏫 **レイ**: 「まず、ユイちゃんに質問。PythonやJavaScriptでメモリ管理って意識したことある？」
>
> 👩‍💻 **ユイ**: 「ないです！変数作ったら勝手に消えますよね。」
>
> 👩‍🏫 **レイ**: 「それが**ガベージコレクタ（GC）**の仕事よ。」

```python
# Python
def create_list():
    data = [1, 2, 3, 4, 5]  # メモリを確保
    return data
    # 関数終了後、dataへの参照がなくなったらGCが解放

result = create_list()
# GCが「result」がまだ参照されているか定期的にチェック
```

> 👩‍🏫 **レイ**: 「GCは便利だけど、実は**大きなコスト**を払ってるの。ホワイトボードに書くわね。」

### GCの問題点

（レイがホワイトボードに書き始める）

> 👩‍🏫 **レイ**: 「GCの隠れたコストは4つあるわ。」

**1. パフォーマンスの一時停止（Stop-the-World）**

> 👩‍🏫 **レイ**: 「GCが動くと、数ミリ秒から数百ミリ秒、プログラムが**止まる**の。」
>
> 👩‍💻 **ユイ**: 「えっ、止まるんですか！？」
>
> 👩‍🏫 **レイ**: 「そう。ゲームとか取引システムみたいなリアルタイム処理では**致命的**よね。」

**2. 予測不能性**

> 👩‍🏫 **レイ**: 「いつGCが動くか分からないから、レイテンシが安定しないの。本番環境で突然遅くなる、みたいなことが起きる。」

**3. メモリ使用量の増大**

> 👩‍🏫 **レイ**: 「解放が遅れるから、必要以上にメモリを消費するのよ。PythonやNode.jsは、同じ処理でもRustの数倍メモリを使うわ。」

**4. CPUオーバーヘッド**

> 👩‍🏫 **レイ**: 「参照カウントの更新とか、マーク＆スイープのトラバーサルとか、GC自体がCPUを食うのよね。」
>
> 👩‍💻 **ユイ**: 「うわぁ…GCって便利だけど、そんなに問題あるんですね…。」

### 手動メモリ管理（C/C++）の問題点

> 👩‍🏫 **レイ**: 「じゃあGCを使わなければいいのかって言うと、それも問題なの。C/C++みたいに手動でメモリ管理すると、別の深刻な問題が起きるわ。」

```c
// C言語: ダングリングポインタ（解放済みメモリへのポインタ）
int* create_array() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // 危険！ローカル変数へのポインタを返している
}  // arrは関数終了時に解放される → ダングリングポインタ

// C言語: 二重解放
int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 未定義動作！メモリ破壊やクラッシュの原因
```

> 👩‍🏫 **レイ**: 「これらのバグは**実行時まで気づかない**ことが多くて、セキュリティ脆弱性の最大の原因なの。」
>
> 👩‍💻 **ユイ**: 「うーん…GCも問題あるし、手動も危険…。どうすればいいんですか？」

### Rustの革新的な解決策

> 👩‍🏫 **レイ**: 「そこで登場するのがRustの所有権システムよ！」

（レイがホワイトボードに大きく書く）

**『コンパイル時に』メモリの有効期間を完全に決定**

> 👩‍🏫 **レイ**: 「これがRustの革新なの。実行時じゃなくて、**コンパイル時に**決めるのよ。」

**結果:**
- ✅ **GCなし** → 予測可能なパフォーマンス、低メモリ使用量
- ✅ **安全** → ダングリングポインタ、二重解放はコンパイルエラー
- ✅ **データ競合なし** → マルチスレッドも安全

**代償:**
- ⚠️ **学習コスト** → 所有権の概念を理解する必要がある
- ⚠️ **コンパイルエラーとの対話** → 最初は多くのエラーに遭遇

> 👩‍💻 **ユイ**: 「コンパイル時にメモリ管理を決めるって、どういうことですか…？」
>
> 👩‍🏫 **レイ**: 「順番に説明していくわ。まずは所有権の3つのルールから。」

---

## 所有権の3つのルール

> 👩‍🏫 **レイ**: 「これだけ覚えれば8割OK。」

（レイがホワイトボードに大きく書く）

1. **Rustのすべての値には「所有者」となる変数がある**
2. **所有者は常に1つだけ**
3. **所有者がスコープを抜けると、値は自動的に破棄される**

> 👩‍💻 **ユイ**: 「所有者…？」
>
> 👩‍🏫 **レイ**: 「そう。Rustでは、すべてのデータに『持ち主』がいるの。そして、持ち主は**1人だけ**。」
>
> 👩‍💻 **ユイ**: 「なんか…独占欲強いですね（笑）。」
>
> 👩‍🏫 **レイ**: 「まあね（笑）。でも、これが安全性の鍵なのよ。具体例を見てみましょう。」

---

## スコープと破棄

```rust
fn main() {
    {
        let s = String::from("hello");  // sが所有者になる
        println!("{}", s);
    }  // sがスコープを抜ける → メモリ解放（drop）

    // println!("{}", s);  // ❌ エラー！sはもう存在しない
}
```

> 👩‍🏫 **レイ**: 「このコードで何が起きてるか、時系列で説明するわね。」

### このコードで何が起きているか

> 👩‍🏫 **レイ**: （ホワイトボードに図を描きながら）「まず、メモリには『スタック』と『ヒープ』っていう2つの領域があるの。」
>
> 👩‍💻 **ユイ**: 「スタックとヒープ…？」
>
> 👩‍🏫 **レイ**: 「スタックは高速だけど固定サイズ、ヒープは可変サイズだけどちょっと遅い。詳しくは後で説明するわ。今は図を見て。」

```
時間の流れ →

1. { が始まる
   スタック: [空]
   ヒープ: [空]

2. let s = String::from("hello");
   スタック: [s: {ptr, len: 5, cap: 5}]
   ヒープ: ["hello" のバイト列]

3. println!("{}", s);
   sを通じてヒープのデータを読む

4. } でスコープ終了
   → Rustが自動的に drop(s) を呼ぶ
   → ヒープの "hello" が解放される
   スタック: [空]
   ヒープ: [空]
```

> 👩‍💻 **ユイ**: 「スタックに`ptr, len, cap`があって、ヒープに実際のデータがあるんですね。」
>
> 👩‍🏫 **レイ**: 「そう！スタックには『メタデータ』（ポインタ、長さ、容量）、ヒープには『実際の文字列データ』があるの。そして、`}`でスコープを抜けた瞬間に、Rustが**自動的に**メモリを解放するのよ。」
>
> 👩‍💻 **ユイ**: 「PythonだとGCが『後で』解放するけど、Rustは『瞬間に』解放するんですね！」
>
> 👩‍🏫 **レイ**: 「完璧！だから予測可能なの。」

**PythonやTypeScriptとの違い:**

| | Python/TypeScript | Rust |
|---|---|---|
| 解放のタイミング | GCが「後で」解放（いつかは不明） | スコープを抜けた**瞬間に**解放 |
| 予測可能性 | 低い | 高い |
| リソース管理 | `with`文や`try-finally`が必要 | 自動（RAII） |

> 👩‍💻 **ユイ**: 「RAII…？」
>
> 👩‍🏫 **レイ**: 「Resource Acquisition Is Initialization。リソースの確保は初期化時、解放は破棄時に自動でやるって考え方よ。Rustの哲学ね。」

---

## ムーブ（移動）— 所有権の移転

> 👩‍🏫 **レイ**: 「じゃあ、最初のエラーに戻りましょう。」

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // 所有権がs1からs2に「ムーブ」

    println!("{}", s1);  // ❌ コンパイルエラー！
    println!("{}", s2);  // ✅ OK
}
```

> 👩‍💻 **ユイ**: 「これです！なんで`s1`が使えなくなるんですか！？」
>
> 👩‍🏫 **レイ**: 「いい質問ね。メモリの視点で説明するわ。」

### なぜムーブが起きるのか — メモリの視点で理解する

> 👩‍🏫 **レイ**: （ホワイトボードに図を描く）「まず、`s1 = String::from("hello")`の後のメモリ状態はこうよ。」

```
┌─────────────────────────────────────────────────────────────────┐
│  s1 = String::from("hello") の後のメモリ状態                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                      ヒープ                            │
│  ┌─────────────────┐          ┌──────────────────┐              │
│  │ s1              │          │ インデックス  値  │              │
│  ├─────────────────┤          ├──────────────────┤              │
│  │ ptr ────────────│────────→ │ 0           'h'  │              │
│  │ len: 5          │          │ 1           'e'  │              │
│  │ capacity: 5     │          │ 2           'l'  │              │
│  └─────────────────┘          │ 3           'l'  │              │
│                               │ 4           'o'  │              │
│  ※ ptr, len, capはスタック上    └──────────────────┘              │
│  ※ 実際の文字データはヒープ上                                     │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「なるほど。スタックにメタデータ、ヒープに実データですね。」
>
> 👩‍🏫 **レイ**: 「そう。じゃあ、`s2 = s1`の後はどうなるか…」

```
┌─────────────────────────────────────────────────────────────────┐
│  s2 = s1 の後のメモリ状態（ムーブ後）                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                      ヒープ                            │
│  ┌─────────────────┐          ┌──────────────────┐              │
│  │ s1 (無効)       │          │ インデックス  値  │              │
│  ├─────────────────┤          ├──────────────────┤              │
│  │ (使用不可)      │          │ 0           'h'  │              │
│  │                 │     ┌──→ │ 1           'e'  │              │
│  └─────────────────┘     │    │ 2           'l'  │              │
│                          │    │ 3           'l'  │              │
│  ┌─────────────────┐     │    │ 4           'o'  │              │
│  │ s2              │     │    └──────────────────┘              │
│  ├─────────────────┤     │                                      │
│  │ ptr ────────────│─────┘    s1のptr, len, capがs2にコピーされ │
│  │ len: 5          │          s1は「無効」としてマークされる      │
│  │ capacity: 5     │                                            │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍🏫 **レイ**: 「ポイントは、`s1`のメタデータ（ptr, len, cap）が`s2`にコピーされて、`s1`が**無効**としてマークされることよ。」
>
> 👩‍💻 **ユイ**: 「あっ！ヒープのデータはコピーされてないんですね。ポインタだけコピーされて…」
>
> 👩‍🏫 **レイ**: 「その通り！これを**ムーブ（移動）**って呼ぶの。所有権が`s1`から`s2`に移ったのよ。」

### もし両方が有効だったら何が起きる？

> 👩‍💻 **ユイ**: 「でも、なんで`s1`を無効にする必要があるんですか？両方使えた方が便利じゃないですか？」
>
> 👩‍🏫 **レイ**: 「いい質問ね。もし両方が有効だったら、**二重解放（double free）**っていう深刻なバグが起きるの。」

（レイがホワイトボードに書く）

```
危険な仮想シナリオ（Rustでは起きないが、Cでは起きうる）:

1. s1とs2が両方とも同じヒープデータを指している
2. } でスコープ終了
3. s2のdropでヒープデータを解放
4. s1のdropで「既に解放されたメモリ」を再度解放しようとする
   → 二重解放（double free）→ メモリ破壊、クラッシュ、セキュリティ脆弱性
```

> 👩‍💻 **ユイ**: 「うわぁ…それは怖いですね…。」
>
> 👩‍🏫 **レイ**: 「でしょ？Rustは『所有者は1つだけ』ルールで、`s1`を無効化するの。これで二重解放は**原理的に不可能**になるわ。」
>
> 👩‍💻 **ユイ**: 「なるほど…！だから厳しいんですね。」

### Pythonとの比較

> 👩‍💻 **ユイ**: 「Pythonだとどうなるんですか？」
>
> 👩‍🏫 **レイ**: 「Pythonは**参照カウント**っていう仕組みを使ってるわ。」

```python
s1 = "hello"
s2 = s1  # 参照のコピー（両方が同じオブジェクトを指す）
print(s1)  # ✅ OK
print(s2)  # ✅ OK
# → 両方使える。GCが参照カウントを管理している
```

> 👩‍🏫 **レイ**: 「Pythonでは『何個の変数がこのオブジェクトを指しているか』を追跡してるの。すべての参照がなくなったときに解放される。」

```
Python のメモリモデル:
s1 = "hello"
s2 = s1

┌─────────────────┐     ┌──────────────────┐
│ s1 ─────────────│────→│ "hello"          │ ← refcount: 2
│ s2 ─────────────│────→│ (参照カウント: 2) │
└─────────────────┘     └──────────────────┘
```

> 👩‍💻 **ユイ**: 「参照カウントで管理してるから、両方使えるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。でも、参照カウントの更新自体がオーバーヘッドになるの。Rustは所有権で管理するから、実行時のオーバーヘッドがゼロなのよ。」

---

## Copyトレイト — ムーブしない型

> 👩‍💻 **ユイ**: 「あれ、でも整数とかはムーブしないですよね？」

```rust
fn main() {
    let x = 5;
    let y = x;  // コピー（ムーブではない）

    println!("x = {}, y = {}", x, y);  // ✅ 両方使える
}
```

> 👩‍🏫 **レイ**: 「よく気づいたわね！整数みたいな**スタック上に収まる単純な型**は、代入時に『ムーブ』じゃなくて『コピー』されるの。」
>
> 👩‍💻 **ユイ**: 「なんでですか？」

### なぜ整数はコピーなのか？

> 👩‍🏫 **レイ**: （ホワイトボードに描く）「整数のメモリ表現を見てみましょう。」

```
整数のメモリ表現:

let x = 5;
┌─────────────────┐
│ x: 5            │  ← スタック上に直接値が入る（ヒープを使わない）
└─────────────────┘

let y = x;
┌─────────────────┐
│ x: 5            │  ← そのまま
└─────────────────┘
┌─────────────────┐
│ y: 5            │  ← 値をコピー（コストは無視できるほど小さい）
└─────────────────┘
```

> 👩‍🏫 **レイ**: 「整数は4バイトで固定だから、スタック上に直接値が入るの。ヒープを使わないから、コピーしても二重解放の心配がないわ。」
>
> 👩‍💻 **ユイ**: 「なるほど！ヒープを使う型（Stringとか）はムーブ、スタックだけの型はコピーなんですね。」
>
> 👩‍🏫 **レイ**: 「完璧！」

**Copy可能な条件:**
1. スタック上に完全に収まる（ヒープを使わない）
2. コピーのコストが非常に小さい

**Copyトレイトを実装している型:**
- 整数型（`i32`, `u64`など）
- 浮動小数点数（`f32`, `f64`）
- ブール型（`bool`）
- 文字型（`char`）
- 上記のみで構成されるタプル（例: `(i32, bool)`）

**ヒープを使う型**（`String`, `Vec<T>`, `Box<T>`など）は**ムーブ**します。

---

## 借用（Borrowing）— 所有権を渡さずに使う

> 👩‍💻 **ユイ**: 「でも、毎回ムーブしてたら不便じゃないですか？関数に渡したら使えなくなっちゃうし…。」
>
> 👩‍🏫 **レイ**: 「そう！だから**借用（Borrowing）**っていう仕組みがあるの。『値を使いたいけど、所有権は渡したくない』って場面で使うわ。」

### 不変の借用（`&`）

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // &s = sへの参照（借用）
    println!("'{}' の長さは {}", s, len);  // sはまだ使える！
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // sは借用なので、ここでdropされない
```

> 👩‍💻 **ユイ**: 「おお！`&s`にすると、`s`がまだ使えるんですね！」
>
> 👩‍🏫 **レイ**: 「そう。`&`は『参照』を作る記号よ。図で説明するわね。」

### `&`記号を理解する

> 👩‍🏫 **レイ**: （ホワイトボードに描く）「`&s`は『sへの参照を作る』って意味よ。」

```
┌─────────────────────────────────────────────────────────────────┐
│  & の意味                                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  &s は「sへの参照を作る」                                        │
│                                                                 │
│  参照とは:                                                       │
│  - 値を指し示すポインタのようなもの                               │
│  - 所有権を持たない（借りているだけ）                             │
│  - 元の値が有効な間だけ使える                                     │
│                                                                 │
│  メモリ表現:                                                     │
│  ┌─────────────────┐     ┌─────────────────┐     ┌──────────┐  │
│  │ &s (参照)       │     │ s (所有者)       │     │ ヒープ   │  │
│  ├─────────────────┤     ├─────────────────┤     ├──────────┤  │
│  │ ptr ────────────│────→│ ptr ────────────│────→│ "hello"  │  │
│  └─────────────────┘     │ len: 5          │     └──────────┘  │
│                          │ cap: 5          │                   │
│                          └─────────────────┘                   │
│                                                                 │
│  参照は「所有者sのアドレス」を指す                                │
│  ヒープデータにはsを経由してアクセス                              │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「参照は『借りてるだけ』だから、所有権は移動しないんですね！」
>
> 👩‍🏫 **レイ**: 「完璧！だから関数から戻ってきても、元の変数がまだ使えるの。」

**`&String`型の読み方:**
- `&` = 参照
- `String` = 参照先の型
- つまり「Stringへの参照」

> 👩‍💻 **ユイ**: 「Pythonだと常に参照渡しみたいな感じですけど、Rustは明示的に`&`を書くんですね。」
>
> 👩‍🏫 **レイ**: 「その通り！Rustは『暗黙的』を嫌うの。すべて明示的に書くから、コードを読めば何が起きてるか分かるのよ。」

### 可変の借用（`&mut`）

> 👩‍🏫 **レイ**: 「値を**変更したい**場合は`&mut`（可変参照）を使うわ。」

```rust
fn main() {
    let mut s = String::from("hello");  // mutが必要
    change(&mut s);
    println!("{}", s);  // "hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

> 👩‍💻 **ユイ**: 「あっ、`let mut`と`&mut`の両方が必要なんですね。」
>
> 👩‍🏫 **レイ**: 「そう。1行ずつ読み解いてみましょう。」

### `&mut`を行ごとに読み解く

```rust
let mut s = String::from("hello");
```

> 👩‍🏫 **レイ**: 「`let mut` = 変更可能な変数として宣言。これがないと可変参照を作れないわ。」

```rust
change(&mut s);
```

> 👩‍🏫 **レイ**: 「`&mut s` = sへの**可変**参照を作成。『sを変更可能な状態で貸し出す』って意味よ。」

```rust
fn change(s: &mut String) {
```

> 👩‍🏫 **レイ**: 「`s: &mut String` = 『Stringへの可変参照』を受け取る。この関数内でsを変更できるわ。」

```rust
s.push_str(", world");
```

> 👩‍🏫 **レイ**: 「可変参照を通じて、元のStringに文字列を追加。`main`関数の`s`が実際に変更されるの。」
>
> 👩‍💻 **ユイ**: 「なるほど！可変参照は『変更する権限を借りる』イメージですね。」

---

## 借用の3つのルール — データ競合を防ぐ

> 👩‍🏫 **レイ**: 「借用には**超重要な3つのルール**があるわ。これがRustの安全性の核心よ。」

（レイがホワイトボードに大きく書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  借用のルール                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ルール1: 不変参照（&T）は同時にいくつでもOK                      │
│           → 「読み取りは何人でも同時にできる」                    │
│                                                                 │
│  ルール2: 可変参照（&mut T）は同時に1つだけ                       │
│           → 「書き込みは1人だけ」                                │
│                                                                 │
│  ルール3: 不変参照と可変参照は同時に存在できない                  │
│           → 「誰かが読んでいる間は書き込めない」                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「えっ、可変参照は**1つだけ**なんですか！？」
>
> 👩‍🏫 **レイ**: 「そう。厳しいでしょ？でも、これには深い理由があるの。」

### 具体例で理解する

**OK: 不変参照は複数持てる**

```rust
fn main() {
    let s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &s;  // いくつでもOK

    println!("{}, {}, {}", r1, r2, r3);
}
```

> 👩‍💻 **ユイ**: 「読み取りだけなら何個でもいいんですね。」

**OK: 参照を使い終わった後なら可変参照を作れる**

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);  // r1, r2はここで最後の使用

    // r1, r2はもう使われない → 可変参照を作れる
    let r3 = &mut s;
    println!("{}", r3);
}
```

> 👩‍🏫 **レイ**: 「ポイントは、『参照が使われなくなったタイミング』でライフタイムが終わることよ。」

**NG: 不変参照と可変参照の同時使用**

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;          // 不変参照
    let r2 = &mut s;      // ❌ エラー！

    println!("{}, {}", r1, r2);
}
```

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:14
  |
4 |     let r1 = &s;
  |              -- immutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ mutable borrow occurs here
6 |     println!("{}, {}", r1, r2);
  |                        -- immutable borrow later used here
```

> 👩‍💻 **ユイ**: 「また怒られた…。」
>
> 👩‍🏫 **レイ**: 「でも、エラーメッセージ読んでみて。『immutable borrowがあるからmutable borrowできない』って書いてあるでしょ？」
>
> 👩‍💻 **ユイ**: 「確かに…！親切ですね。」

### なぜこのルールが必要なのか — データ競合

> 👩‍💻 **ユイ**: 「でも、なんでこんなに厳しいんですか？」
>
> 👩‍🏫 **レイ**: 「**データ競合（Data Race）**を防ぐためよ。」

（レイがホワイトボードに書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  データ競合の条件（すべて満たすと発生）                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 2つ以上のポインタが同じデータにアクセス                      │
│  2. 少なくとも1つが書き込み                                      │
│  3. アクセスが同期されていない                                   │
│                                                                 │
│  Rustの借用ルールは、この条件を「コンパイル時に」防ぐ             │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍🏫 **レイ**: 「例えば、JavaScriptでこんなバグがあるわ。」

```javascript
const arr = [1, 2, 3];

// 配列を反復しながら変更 → 予期しない動作
arr.forEach((item, i) => {
    if (item === 2) arr.push(4);  // 反復中に変更！
});
console.log(arr);  // [1, 2, 3, 4] だが、ループ回数が変わる可能性
```

> 👩‍💻 **ユイ**: 「あー！これ、前にハマったことあります！」
>
> 👩‍🏫 **レイ**: 「Rustなら、イテレータで借用中のコレクションを変更しようとすると**コンパイルエラー**になるの。」
>
> 👩‍💻 **ユイ**: 「そっか…！だから『誰かが読んでいる間は書き込めない』んですね。」
>
> 👩‍🏫 **レイ**: 「その通り！Rustは『実行時のバグ』を『コンパイル時のエラー』に変えてくれるのよ。」

---

## ライフタイム — 参照の有効期間

> 👩‍🏫 **レイ**: 「次は**ライフタイム**。参照が『どのくらい生きているか』を表すわ。」

### ダングリング参照の防止

```rust
fn main() {
    let r;                // ← rをここで宣言
    {
        let x = 5;
        r = &x;           // ← xへの参照をrに代入
    }                     // ← xがここで破棄される
    println!("{}", r);    // ❌ xはもう存在しない！
}
```

```
error[E0597]: `x` does not live long enough
 --> src/main.rs:5:13
  |
4 |         let x = 5;
  |             - binding `x` declared here
5 |         r = &x;
  |             ^^ borrowed value does not live long enough
6 |     }
  |     - `x` dropped here while still borrowed
7 |     println!("{}", r);
  |                    - borrow later used here
```

> 👩‍💻 **ユイ**: 「『does not live long enough』…xが十分長く生きてないって言われてる…。」
>
> 👩‍🏫 **レイ**: 「そう！Rustコンパイラは『rがxより長生きしようとしている』ことを検出して、エラーにしてくれるの。」

### コンパイラはどうやって検出するか

> 👩‍🏫 **レイ**: （ホワイトボードに描く）「コンパイラは各変数に**ライフタイム**（生存期間）を割り当ててるのよ。」

```rust
fn main() {
    let r;                // ─────────┐ 'a: rのライフタイム
    {                     //          │
        let x = 5;        // ─┐ 'b    │
        r = &x;           //  │       │
    }                     // ─┘ xが'bで終了、しかしrは'aで続く
    println!("{}", r);    //          │
}                         // ─────────┘
```

> 👩‍🏫 **レイ**: 「`'b`（xのライフタイム）が`'a`（rのライフタイム）より短いから、エラーになるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…！コンパイラが『無効な参照』を検出してくれるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。C言語だとこれが**ダングリングポインタ**っていう深刻なバグになるのよ。」

---

## ライフタイム注釈 `'a` — 明示的なライフタイム指定

> 👩‍🏫 **レイ**: 「関数が**参照を返す**場合、コンパイラに『戻り値がどこまで有効か』を教える必要があるわ。」

### なぜライフタイム注釈が必要か

```rust
// ❌ コンパイルエラー！
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value,
          but the signature does not say whether it is borrowed from `x` or `y`
```

> 👩‍💻 **ユイ**: 「『xから借りてるのか、yから借りてるのか分からない』って言われてる…。」
>
> 👩‍🏫 **レイ**: 「そう！戻り値の参照は`x`から来るかもしれないし、`y`から来るかもしれない。コンパイラは『どちらのライフタイムを使えばいいか』わからないの。」

### ライフタイム注釈の書き方

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

> 👩‍💻 **ユイ**: 「`'a`って何ですか！？アポストロフィ？」
>
> 👩‍🏫 **レイ**: 「これがライフタイム注釈よ。読み方を教えるわね。」

### `'a`を読み解く

> 👩‍🏫 **レイ**: （ホワイトボードに書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  <'a>                                                           │
│    └─ ライフタイムパラメータを宣言（型パラメータ<T>と同じ位置）   │
│                                                                 │
│  x: &'a str                                                     │
│    └─ 「xはライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  y: &'a str                                                     │
│    └─ 「yもライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  -> &'a str                                                     │
│    └─ 「戻り値もライフタイム'aの間有効」                         │
│                                                                 │
│  意味:                                                           │
│  「xとyの両方が有効な間、戻り値も有効」                          │
│  → 実際には「xとyの短い方」のライフタイムが'aになる              │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「うーん…難しいですね…。」
>
> 👩‍🏫 **レイ**: 「最初はね。でも大丈夫、ほとんどの場合コンパイラが推論してくれるわ。エラーが出たら、エラーメッセージに従って追加すればいいの。」
>
> 👩‍💻 **ユイ**: 「そっか、またコンパイラと対話すればいいんですね。」
>
> 👩‍🏫 **レイ**: 「その調子！」

### よく使うライフタイム

| ライフタイム | 意味 |
|------------|------|
| `'a`, `'b` | 一般的なライフタイムパラメータ |
| `'static` | プログラム全体で有効（文字列リテラルなど） |
| `'_` | ライフタイムの省略（コンパイラが推論） |

**`'static`の例:**

```rust
let s: &'static str = "Hello, world!";  // 文字列リテラルは'static
```

> 👩‍🏫 **レイ**: 「文字列リテラルは、プログラムのバイナリに埋め込まれるから、プログラム全体で有効なの。だから`'static`。」

---

## スタックとヒープ — メモリレイアウトの理解

> 👩‍🏫 **レイ**: 「さっきから『スタック』『ヒープ』って言ってるけど、ちゃんと説明するわね。」

### スタックとヒープの違い

> 👩‍🏫 **レイ**: （ホワイトボードに表を書く）

| 領域 | 特徴 | 格納されるもの | アクセス速度 |
|-----|------|--------------|------------|
| スタック | 固定サイズ、LIFO、自動解放 | 整数、参照、固定長配列 | 非常に高速 |
| ヒープ | 可変サイズ、動的確保、明示的解放 | String, Vec, Boxなど | やや遅い |

> 👩‍💻 **ユイ**: 「LIFO…？」
>
> 👩‍🏫 **レイ**: 「Last In, First Out。後から入れたものが先に出る、スタック構造ね。関数呼び出しもスタックで管理されてるわ。」

### メモリレイアウトの図解

```rust
fn main() {
    let x = 5;                      // スタック上に直接格納
    let s = String::from("hello");  // ヒープにデータ、スタックにメタデータ
}
```

> 👩‍🏫 **レイ**: （ホワイトボードに描く）

```
┌─────────────────────────────────────────────────────────────────┐
│  メモリレイアウト                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック（高速、サイズ固定）         ヒープ（可変サイズ）        │
│  ┌─────────────────────────┐         ┌───────────────────┐     │
│  │ x: 5                    │         │ 'h' 'e' 'l' 'l' 'o'│     │
│  ├─────────────────────────┤         └───────────────────┘     │
│  │ s:                      │                  ↑                │
│  │   ptr ─────────────────────────────────────┘                │
│  │   len: 5                │                                   │
│  │   capacity: 5           │                                   │
│  └─────────────────────────┘                                   │
│                                                                 │
│  整数(5)は4バイトで固定 → スタックに直接                         │
│  String("hello")はサイズ可変 → ヒープにデータ                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「なるほど！整数はサイズが決まってるからスタック、文字列はサイズが可変だからヒープなんですね。」
>
> 👩‍🏫 **レイ**: 「完璧！Python/JavaScriptだとほぼすべてがヒープ上のオブジェクトだけど、Rustはプログラマが使い分けるの。」
>
> 👩‍💻 **ユイ**: 「それで速いんですね。」

---

## 実践パターン

> 👩‍🏫 **レイ**: 「最後に、よく使うパターンをまとめておくわね。」

### パターン1: 関数に値を渡す3つの方法

```rust
// 1. 所有権を取る（呼び出し元は使えなくなる）
fn takes_ownership(s: String) {
    println!("{}", s);
}  // sがdropされる

// 2. 不変借用（呼び出し元も使える、変更不可）
fn borrows(s: &String) {
    println!("{}", s);
}  // sは借用なのでdropされない

// 3. 可変借用（変更できる）
fn mutates(s: &mut String) {
    s.push_str("!");
}

fn main() {
    let s1 = String::from("hello");
    takes_ownership(s1);
    // println!("{}", s1);  // ❌ s1はムーブ済み

    let s2 = String::from("hello");
    borrows(&s2);
    println!("{}", s2);  // ✅ OK "hello"

    let mut s3 = String::from("hello");
    mutates(&mut s3);
    println!("{}", s3);  // ✅ OK "hello!"
}
```

> 👩‍💻 **ユイ**: 「状況に応じて使い分けるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。基本は**借用**を使って、本当に所有権が必要なときだけムーブするのがRust流よ。」

### パターン2: clone()で明示的にコピー

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深いコピー（ヒープデータもコピー）

    println!("s1 = {}, s2 = {}", s1, s2);  // ✅ 両方使える
}
```

> 👩‍🏫 **レイ**: 「本当にコピーが必要なら`clone()`を使うわ。でも、ヒープデータもコピーするから**コストがかかる**のよ。」
>
> 👩‍💻 **ユイ**: 「必要な場合のみ使うんですね。」

---

## まとめ

> 👩‍🏫 **レイ**: 「長かったわね。今日のまとめよ。」

| 概念 | 説明 | Python/TSとの違い |
|-----|------|------------------|
| 所有権 | 値には所有者が1つだけ | GC言語では意識不要 |
| ムーブ | 代入で所有権が移動 | 参照のコピー（両方使える） |
| `&`（借用） | 不変参照を作成 | 明示的に書く必要がある |
| `&mut` | 可変借用（同時に1つだけ） | 制限なし（データ競合のリスク） |
| ライフタイム`'a` | 参照の有効期間 | GCが管理 |

> 👩‍💻 **ユイ**: 「めちゃくちゃ頭使いました…。でも、なんとなく分かった気がします！」
>
> 👩‍🏫 **レイ**: 「最初はそれで十分よ。所有権は**書いて慣れる**のが一番。コンパイラがエラー出してくれるから、恐れずにコード書いてみて。」
>
> 👩‍💻 **ユイ**: 「はい！エラーメッセージちゃんと読みます！」
>
> 👩‍🏫 **レイ**: 「その調子。最初は戸惑うけど、慣れると『バグが実行前に見つかる』安心感が病みつきになるわよ。」
>
> 👩‍💻 **ユイ**: 「楽しみです！」

---

## ポイント

- 所有権システムにより、**GCなしでメモリ安全を保証**
- `&`は「借用」、`&mut`は「可変借用」
- 借用のルールで**データ競合を防ぐ**
- ライフタイムは「参照がどのくらい有効か」をコンパイラに伝える
- **コンパイラと対話** — エラーが出たらメッセージをよく読む
- 最初は戸惑うが、慣れると「バグが実行前に見つかる」安心感がある

---

## よくあるコンパイルエラーと対処法

> 👩‍🏫 **レイ**: 「最後に、よく出るエラーと対処法をメモしておくわね。」

**エラー1: `value borrowed here after move`**

```
error[E0382]: borrow of moved value: `s`
```

**原因:** ムーブした後の値を使おうとした
**対処:** `clone()`するか、借用（`&`）を使う

```rust
// ❌ let s2 = s1; println!("{}", s1);
// ✅ let s2 = s1.clone(); println!("{}", s1);
// ✅ let s2 = &s1; println!("{}", s1);
```

**エラー2: `cannot borrow as mutable`**

```
error[E0596]: cannot borrow `s` as mutable, as it is not declared as mutable
```

**原因:** `mut`なしの変数を可変借用しようとした
**対処:** 変数宣言に`mut`を追加

```rust
// ❌ let s = String::from("hello"); s.push_str("!");
// ✅ let mut s = String::from("hello"); s.push_str("!");
```

**エラー3: `does not live long enough`**

```
error[E0597]: `x` does not live long enough
```

**原因:** 参照が参照先より長生きしようとしている
**対処:** ライフタイムを見直す、または所有権を渡す

---

## 次のステップ

> 👩‍🏫 **レイ**: 「次は**構造体と列挙型**よ。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能ね。」
>
> 👩‍💻 **ユイ**: 「所有権の知識を活かすんですね！」
>
> 👩‍🏫 **レイ**: 「そう。特に`self`と`&self`の使い分けが重要よ。楽しみにしててね！」

[Chapter 03: 構造体・列挙型](03-structs-enums-dialogue.md) では、Rustでデータを構造化する方法を学びます。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能です。所有権の知識を活かして、`self`と`&self`の使い分けを理解しましょう。
