# Chapter 02: 所有権

> **この章で学ぶこと**: 所有権、借用（`&`と`&mut`）、ライフタイム — Rust最大の特徴にして最重要概念

> 📖 **記号リファレンス**: この章では `&`, `&mut`, `'a` など重要な記号が登場します。意味がわからなくなったら [Chapter 11: 記号・構文リファレンス](11-syntax-reference.md) を参照してください。

---

## プロローグ：所有権との遭遇

> 👩‍💻 **ユイ**: 「先輩！また怒られました！！」
>
> 👩‍🏫 **レイ**: 「落ち着いて。何のエラー？」
>
> 👩‍💻 **ユイ**: 「これです…」

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);  // ❌ エラー！
}
```

```
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:20
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
```

> 👩‍💻 **ユイ**: 「『value moved here』って何ですか！？`s2 = s1`って普通の代入じゃないんですか！？Pythonなら両方使えるのに…！なんか私、Rustに嫌われてます…？」
>
> 👩‍🏫 **レイ**: （優しく笑って）「嫌われてないわよ。むしろ**守られてる**の。」
>
> 👩‍💻 **ユイ**: 「守られてる…？エラー出てるのに？」
>
> 👩‍🏫 **レイ**: 「そう。このエラーは、実行時に起きるはずだった**深刻なバグ**をコンパイル時に防いでくれてるの。いよいよRustの本丸、**所有権システム**よ。」
>
> 👩‍💻 **ユイ**: 「所有権…！Chapter 01で予告されてたやつですね。」
>
> 👩‍🏫 **レイ**: 「これはRust最大の特徴にして、最も理解しづらいところ。でも、一度理解すれば『なんでPythonにこれがないの！？』ってなるわよ。ホワイトボード使って、ゼロから説明するわね。」

---

## なぜ所有権が必要なのか — 本当の理由

> 👩‍🏫 **レイ**: 「まず、ユイちゃんに質問。PythonやJavaScriptでメモリ管理って意識したことある？」
>
> 👩‍💻 **ユイ**: 「ないです！変数作ったら勝手に消えますよね。」
>
> 👩‍🏫 **レイ**: 「それが**ガベージコレクタ（GC）**の仕事よ。」

```python
# Python
def create_list():
    data = [1, 2, 3, 4, 5]  # メモリを確保
    return data
    # 関数終了後、dataへの参照がなくなったらGCが解放

result = create_list()
# GCが「result」がまだ参照されているか定期的にチェック
```

> 👩‍🏫 **レイ**: 「GCは便利だけど、実は**大きなコスト**を払ってるの。ここからが重要だから、ちゃんと聞いて。」
>
> 👩‍💻 **ユイ**: 「はい！」

### GCの問題点 — なぜRustはGCを排除したのか

（レイがホワイトボードに書き始める）

> 👩‍🏫 **レイ**: 「GCには4つの隠れたコストがあるわ。**システムプログラミング**の世界では、これらが致命的になることがあるの。」

**1. 予測不能な一時停止（Stop-the-World）**

> 👩‍🏫 **レイ**: 「GCが動くと、数ミリ秒から数百ミリ秒、プログラムが**完全に止まる**の。」
>
> 👩‍💻 **ユイ**: 「えっ、止まるんですか！？」
>
> 👩‍🏫 **レイ**: 「そう。これが**予測不能なタイミング**で起きるの。Webアプリなら『ちょっとレスポンスが遅い』で済むかもしれないけど…」
>
> 👩‍💻 **ユイ**: 「でも済まない場面もある…？」
>
> 👩‍🏫 **レイ**: 「例えばね…」

```
GCが致命的な場面:
┌─────────────────────────────────────────────────────────────────┐
│ 🎮 ゲーム: 60fpsなら1フレーム16ms。GCで50ms止まったら3フレーム   │
│           → カクつく → プレイヤーが死ぬ                         │
│                                                                 │
│ 💹 高頻度取引: 1ミリ秒の遅延が数億円の損失に                     │
│           → GCのタイミングが読めないのは致命的                  │
│                                                                 │
│ 🚗 自動運転: ブレーキ判断の遅延は人命に関わる                    │
│           → 「GCが動いてました」は言い訳にならない               │
│                                                                 │
│ 🔧 OS・ブラウザエンジン: 基盤ソフトウェアが止まると全部止まる    │
│           → Firefox、Linux kernelがRustを採用した理由           │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「ゲームでカクつくの、GCのせいだったりするんですね…！」
>
> 👩‍🏫 **レイ**: 「Javaのゲームが重いって言われる理由の一つよ。」

**2. メモリ使用量の増大**

> 👩‍🏫 **レイ**: 「解放が遅れるから、必要以上にメモリを消費するのよ。」

```
同じ処理のメモリ使用量（目安）:
- C/Rust:   100MB
- Go:       150MB（GCあり、でも軽量）
- Java:     300MB
- Python:   500MB
```

> 👩‍💻 **ユイ**: 「5倍も違うんですか！？」
>
> 👩‍🏫 **レイ**: 「サーバーを1000台動かすクラウド環境だと、メモリコストが5倍違うのは**経営レベルの問題**になるわ。」

**3. CPUオーバーヘッド**

> 👩‍🏫 **レイ**: 「参照カウントの更新、マーク＆スイープのトラバーサル、GC自体がCPUを食うのよね。」

**4. 予測不能性が設計を制限する**

> 👩‍🏫 **レイ**: 「これが一番厄介かも。『いつメモリが解放されるか分からない』から、リソース管理が難しくなるの。ファイルハンドルやネットワーク接続の解放タイミングが読めないのよ。」
>
> 👩‍💻 **ユイ**: 「うわぁ…GCって便利だと思ってたけど、そんなに問題あるんですね…。」

### Rustの革命的アプローチ — 所有権システム

> 👩‍🏫 **レイ**: 「ここでRustの設計者たちは考えたの。『**GCなしで、安全なメモリ管理ができないか？**』って。」
>
> 👩‍💻 **ユイ**: 「GCなしで…？」
>
> 👩‍🏫 **レイ**: 「そう。彼らが出した答えが**所有権システム**よ。」

（レイがホワイトボードに大きく書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  Rustのブレイクスルー                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  「メモリの有効期間を【コンパイル時に】完全に決定する」           │
│                                                                 │
│  GC（実行時）   →  所有権システム（コンパイル時）                │
│                                                                 │
│  実行時のチェック = パフォーマンスコスト                         │
│  コンパイル時のチェック = ゼロコスト！                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「コンパイル時に決める…？」
>
> 👩‍🏫 **レイ**: 「そう。コンパイラが『この変数は、コードのこの地点で解放される』って**静的に**決めるの。実行時にチェックしないから、オーバーヘッドがゼロなのよ。」

**結果:**
- ✅ **GCなし** → 予測可能なパフォーマンス、低メモリ使用量
- ✅ **安全** → ダングリングポインタ、二重解放はコンパイルエラー
- ✅ **データ競合なし** → マルチスレッドも安全

**代償:**
- ⚠️ **学習コスト** → 所有権の概念を理解する必要がある
- ⚠️ **コンパイルエラーとの対話** → 最初は多くのエラーに遭遇

> 👩‍💻 **ユイ**: 「なるほど…さっき『守られてる』って言ってたのは、コンパイラが私のミスを防いでくれてるってことですね。」
>
> 👩‍🏫 **レイ**: 「そういうこと！じゃあ、具体的なルールを見ていきましょう。」

---

## 所有権の3つのルール

> 👩‍🏫 **レイ**: 「これだけ覚えれば8割OK。暗記するくらい何度も読み返して。」

（レイがホワイトボードに大きく書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  所有権の3つのルール（The Three Rules of Ownership）             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Rustのすべての値には「所有者」となる変数がある               │
│                                                                 │
│  2. 所有者は【常に1つだけ】                                      │
│                                                                 │
│  3. 所有者がスコープを抜けると、値は【自動的に】破棄される       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「所有者…？」
>
> 👩‍🏫 **レイ**: 「身近な例えで説明するわね。**部屋の鍵**をイメージして。」

```
🔑 部屋の鍵のたとえ

- 部屋（データ）には必ず鍵（所有者）がある
- 鍵は【1人だけ】が持てる（複製禁止！）
- 鍵を持ってる人が引っ越したら、部屋は解体される

Pythonの世界:
  → 部屋の鍵は複製し放題。誰かが最後に出ていったら管理人（GC）が解体

Rustの世界:
  → 鍵は1つだけ。鍵を持ってる人が去ったら即座に解体
  → だから「誰が鍵を持ってるか」を常にコンパイラが追跡
```

> 👩‍💻 **ユイ**: 「なるほど…！鍵が1つしかないから、誰が持ってるか追跡できるんですね。」
>
> 👩‍🏫 **レイ**: 「そう！そして、これがRustのエラーメッセージの意味に繋がるのよ。さっきの『value moved here』は、『鍵が別の人に渡った』って意味なの。」
>
> 👩‍💻 **ユイ**: 「あっ…だから前の人は鍵を持ってないから、もう部屋に入れないってこと？」
>
> 👩‍🏫 **レイ**: 「完璧！」

---

## スコープと破棄

```rust
fn main() {
    {
        let s = String::from("hello");  // sが所有者になる
        println!("{}", s);
    }  // sがスコープを抜ける → メモリ解放（drop）

    // println!("{}", s);  // ❌ エラー！sはもう存在しない
}
```

> 👩‍🏫 **レイ**: 「このコードで何が起きてるか、時系列で説明するわね。ただ、その前に**スタックとヒープ**の話をしなきゃいけないわ。」
>
> 👩‍💻 **ユイ**: 「スタックとヒープ…？前の章でもちょっと出てきましたよね。」
>
> 👩‍🏫 **レイ**: 「そう。ここ、**絶対に曖昧にしちゃダメ**なところよ。他の言語だと意識しなくていいから、多くの人がなんとなくで済ませがちなんだけど、Rustではここを理解してないと後で必ず痛い目を見るわ。」

### 【重要】スタックとヒープ — メモリの2つの領域

> 👩‍🏫 **レイ**: （ホワイトボードに大きく図を描く）「コンピュータのメモリには、主に2つの領域があるの。」

```
┌─────────────────────────────────────────────────────────────────┐
│  メモリの構造                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  スタック（Stack）                                    │ ↓成長  │
│  │  ─────────────────────────────────────────────────── │       │
│  │  • 固定サイズのデータ専用                              │       │
│  │  • 超高速（CPUが直接管理）                             │       │
│  │  • LIFO（後入れ先出し）= 積み上げ方式                 │       │
│  │  • 関数呼び出しごとに「スタックフレーム」が積まれる    │       │
│  │                                                       │       │
│  │  例: i32(4byte), f64(8byte), bool(1byte), 参照...     │       │
│  └──────────────────────────────────────────────────────┘       │
│                         ⋮（空き領域）                           │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  ヒープ（Heap）                                       │ ↑成長  │
│  │  ─────────────────────────────────────────────────── │       │
│  │  • 可変サイズのデータ用                                │       │
│  │  • やや遅い（OSに確保を依頼）                          │       │
│  │  • 好きな順番で確保・解放可能                          │       │
│  │                                                       │       │
│  │  例: String, Vec<T>, Box<T>...                        │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「2種類あるんですね…なんで分かれてるんですか？」
>
> 👩‍🏫 **レイ**: 「**速度と柔軟性のトレードオフ**よ。」

| 領域 | 速度 | サイズ | 管理 | 用途 |
|-----|------|-------|-----|-----|
| スタック | ⚡超高速 | 固定（コンパイル時に決定） | 自動 | 整数、参照、小さなデータ |
| ヒープ | 🐢やや遅い | 可変（実行時に決定） | 手動（Rustでは所有権で管理） | 文字列、配列、大きなデータ |

> 👩‍💻 **ユイ**: 「じゃあ、スタックだけ使えばいいんじゃないですか？速いなら。」
>
> 👩‍🏫 **レイ**: 「いい質問！でも、**実行時まで長さが分からないデータ**ってあるでしょ？」
>
> 👩‍💻 **ユイ**: 「あっ、ユーザーが入力した文字列とか…」
>
> 👩‍🏫 **レイ**: 「そう！『田中さんが何文字の名前を入力するか』は、コンパイル時には分からないわよね。だからヒープが必要なの。」

### Stringのメモリレイアウト — 物理的に何が起きているか

> 👩‍🏫 **レイ**: 「じゃあ、`String`がメモリ上でどう表現されてるか見てみましょう。」

```
let s = String::from("hello");

┌─────────────────────────────────────────────────────────────────┐
│  メモリレイアウト                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                          ヒープ                        │
│  ┌───────────────────────┐         ┌──────────────────────┐    │
│  │ s                     │         │ index │ value        │    │
│  ├───────────────────────┤         ├───────┼──────────────┤    │
│  │ ptr: 0x7f2a... ───────│────────→│ 0     │ 'h' (0x68)   │    │
│  │ len: 5                │         │ 1     │ 'e' (0x65)   │    │
│  │ capacity: 5           │         │ 2     │ 'l' (0x6c)   │    │
│  └───────────────────────┘         │ 3     │ 'l' (0x6c)   │    │
│        ↑                           │ 4     │ 'o' (0x6f)   │    │
│     24バイト固定                    └──────────────────────┘    │
│    （64bit環境の場合）                   ↑                      │
│                                     5バイト（可変）              │
│                                                                 │
│  ptr = ヒープ上のデータへのポインタ                              │
│  len = 現在の文字列の長さ                                        │
│  capacity = 確保済みのヒープ領域のサイズ                         │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「あっ！スタックには『メタデータ』だけあって、実際の文字はヒープにあるんですね！」
>
> 👩‍🏫 **レイ**: 「その通り！`String`型の変数`s`自体は**スタック上で24バイト固定**なの。64bit環境だと、ポインタが8バイト、lenが8バイト、capacityが8バイトで、合計24バイト。」
>
> 👩‍💻 **ユイ**: 「なるほど…だからコンパイル時に`s`のサイズは分かるんですね。可変なのはヒープ側だけ。」
>
> 👩‍🏫 **レイ**: 「完璧！この理解がムーブを理解する鍵になるわ。」

```
時間の流れ →

1. { が始まる
   スタック: [空]
   ヒープ: [空]

2. let s = String::from("hello");
   スタック: [s: {ptr, len: 5, cap: 5}]
   ヒープ: ["hello" のバイト列]

3. println!("{}", s);
   sを通じてヒープのデータを読む

4. } でスコープ終了
   → Rustが自動的に drop(s) を呼ぶ
   → ヒープの "hello" が解放される
   スタック: [空]
   ヒープ: [空]
```

> 👩‍💻 **ユイ**: 「スタックに`ptr, len, cap`があって、ヒープに実際のデータがあるんですね。」
>
> 👩‍🏫 **レイ**: 「そう！スタックには『メタデータ』（ポインタ、長さ、容量）、ヒープには『実際の文字列データ』があるの。そして、`}`でスコープを抜けた瞬間に、Rustが**自動的に**メモリを解放するのよ。」
>
> 👩‍💻 **ユイ**: 「PythonだとGCが『後で』解放するけど、Rustは『瞬間に』解放するんですね！」
>
> 👩‍🏫 **レイ**: 「完璧！だから予測可能なの。」

**PythonやTypeScriptとの違い:**

| | Python/TypeScript | Rust |
|---|---|---|
| 解放のタイミング | GCが「後で」解放（いつかは不明） | スコープを抜けた**瞬間に**解放 |
| 予測可能性 | 低い | 高い |
| リソース管理 | `with`文や`try-finally`が必要 | 自動（RAII） |

> 👩‍💻 **ユイ**: 「RAII…？」
>
> 👩‍🏫 **レイ**: 「Resource Acquisition Is Initialization。リソースの確保は初期化時、解放は破棄時に自動でやるって考え方よ。Rustの哲学ね。」

---

## ムーブ（移動）— 所有権の移転

> 👩‍🏫 **レイ**: 「じゃあ、最初のエラーに戻りましょう。これが今日の本題よ。」

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // 所有権がs1からs2に「ムーブ」

    println!("{}", s1);  // ❌ コンパイルエラー！
    println!("{}", s2);  // ✅ OK
}
```

> 👩‍💻 **ユイ**: 「これです！なんで`s1`が使えなくなるんですか！？」
>
> 👩‍🏫 **レイ**: 「いい質問ね。**バイトレベル**で何が起きてるか説明するわ。これが分かれば全部分かる。」

### ムーブの物理的な動作 — ビット・バイトレベルで理解する

> 👩‍🏫 **レイ**: （ホワイトボードに詳細な図を描く）「まず、`s1 = String::from("hello")`の後のメモリ状態はこうよ。」

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 1: let s1 = String::from("hello"); の直後                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック（アドレス0x7fff0000付近）                              │
│  ┌─────────────────────────────────────┐                        │
│  │ s1:                                 │                        │
│  │   ptr:      0x5f3e2a10  (8 bytes)   │──→  ヒープへ           │
│  │   len:      5           (8 bytes)   │                        │
│  │   capacity: 5           (8 bytes)   │                        │
│  └─────────────────────────────────────┘                        │
│                   合計 24 bytes                                 │
│                                                                 │
│  ヒープ（アドレス0x5f3e2a10）                                    │
│  ┌─────────────────────────────────────┐                        │
│  │ 'h' 'e' 'l' 'l' 'o'                 │                        │
│  │ 0x68 0x65 0x6c 0x6c 0x6f            │                        │
│  └─────────────────────────────────────┘                        │
│                   5 bytes                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「スタックに24バイト、ヒープに5バイトですね。」
>
> 👩‍🏫 **レイ**: 「そう。じゃあ、`let s2 = s1;`で何が起きるか…**ここが最重要ポイント**よ。」

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 2: let s2 = s1; の実行                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【物理的に起きること】                                          │
│                                                                 │
│  s1のスタック上のデータ（24バイト）を                            │
│  s2のスタック領域に【ビット単位でコピー】する                     │
│                                                                 │
│  コピーされるもの:                                               │
│    ptr:      0x5f3e2a10  →  そのままコピー                      │
│    len:      5           →  そのままコピー                      │
│    capacity: 5           →  そのままコピー                      │
│                                                                 │
│  【コピーされないもの】                                          │
│    ヒープ上の "hello" のデータ（5バイト）                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 2 直後のメモリ状態                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  スタック                                                       │
│  ┌─────────────────────────────────────┐                        │
│  │ s1 (無効化！)                       │                        │
│  │   ptr:      0x5f3e2a10 ────┐        │                        │
│  │   len:      5              │        │                        │
│  │   capacity: 5              │        │                        │
│  └────────────────────────────│────────┘                        │
│  ┌────────────────────────────│────────┐                        │
│  │ s2 (新しい所有者)           │        │                        │
│  │   ptr:      0x5f3e2a10 ────┤        │                        │
│  │   len:      5              │        │                        │
│  │   capacity: 5              │        │                        │
│  └────────────────────────────│────────┘                        │
│                               ↓                                 │
│  ヒープ（同じアドレス0x5f3e2a10）                                │
│  ┌─────────────────────────────────────┐                        │
│  │ 'h' 'e' 'l' 'l' 'o'                 │ ← 1つしかない！        │
│  └─────────────────────────────────────┘                        │
│                                                                 │
│  ⚠️ s1とs2は【同じヒープ領域】を指している                       │
│  ⚠️ だからRustはs1を「無効」としてマークする                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「あっ！ポインタがコピーされただけで、ヒープのデータはコピーされてない！」
>
> 👩‍🏫 **レイ**: 「そう！これがポイントよ。**スタック上の24バイト（ポインタ・長さ・容量）がコピー**されて、**ヒープ上のデータは1つのまま**。」
>
> 👩‍💻 **ユイ**: 「でも、それって危なくないですか？両方が同じデータを指してたら…」
>
> 👩‍🏫 **レイ**: 「鋭い！だからRustは`s1`を**無効化**するの。これが**ムーブ**の本質よ。」

### なぜムーブが必要か — 二重解放の恐怖

> 👩‍🏫 **レイ**: 「もし両方が有効なままだったら、こうなるわ。」

```
┌─────────────────────────────────────────────────────────────────┐
│  【危険】もしs1とs2が両方有効だったら…                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. s1とs2が両方とも同じヒープデータ(0x5f3e2a10)を指す           │
│                                                                 │
│  2. スコープ終了（}）で両方がdropされる                          │
│                                                                 │
│  3. s2のdrop: free(0x5f3e2a10)                                  │
│     → ヒープの "hello" が解放される ✓                           │
│                                                                 │
│  4. s1のdrop: free(0x5f3e2a10)                                  │
│     → 【既に解放されたアドレス】を再度解放しようとする！         │
│                                                                 │
│  結果:                                                           │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 💀 二重解放（Double Free）                                  │ │
│  │    - メモリ破壊                                             │ │
│  │    - プログラムのクラッシュ                                 │ │
│  │    - セキュリティ脆弱性（攻撃者が悪用可能）                  │ │
│  │    - デバッグ困難（再現性がない場合も）                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「うわぁ…それは怖いですね…。」
>
> 👩‍🏫 **レイ**: 「実際、C/C++のセキュリティ脆弱性の**約70%**がメモリ安全性に関するものだと言われてるわ。Microsoftの調査結果よ。」
>
> 👩‍💻 **ユイ**: 「70%も！？」
>
> 👩‍🏫 **レイ**: 「だからRustは『所有者は1つだけ』ルールで、`s1`を無効化するの。これで二重解放は**原理的に不可能**になるわ。」

### ムーブのコスト — なぜ高速か

> 👩‍💻 **ユイ**: 「でも、毎回コピーするのは遅くないですか？」
>
> 👩‍🏫 **レイ**: 「いい質問！実は**めちゃくちゃ高速**なの。」

```
ムーブのコスト:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  コピーされるもの: スタック上の24バイトだけ                      │
│                    （ptr + len + capacity）                     │
│                                                                 │
│  コピーされないもの: ヒープ上のデータ                            │
│                      （"hello"が1MBでも24バイトのコピーだけ）   │
│                                                                 │
│  例: 1MBの文字列をムーブする                                     │
│    - 深いコピー（clone）: 1MB + 24バイト ≒ 1,000,024 バイト      │
│    - ムーブ: 24バイトだけ                                        │
│    → 約40,000倍高速！                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「4万倍！？そんなに違うんですか！」
>
> 👩‍🏫 **レイ**: 「そう。だからRustは**デフォルトでムーブ**なの。安全性と高速性を両立してるのよ。」

### Pythonとの比較 — 参照カウントの仕組み

> 👩‍💻 **ユイ**: 「Pythonだとどうなるんですか？同じことしてもエラーにならないですよね。」
>
> 👩‍🏫 **レイ**: 「Pythonは**参照カウント**っていう仕組みを使ってるわ。」

```python
s1 = "hello"
s2 = s1  # 参照のコピー（両方が同じオブジェクトを指す）
print(s1)  # ✅ OK
print(s2)  # ✅ OK
# → 両方使える。GCが参照カウントを管理している
```

> 👩‍🏫 **レイ**: 「Pythonでは『何個の変数がこのオブジェクトを指しているか』を**実行時に追跡**してるの。」

```
Python のメモリモデル:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  s1 = "hello"                                                   │
│  ┌──────────┐         ┌──────────────────────────────────┐      │
│  │ s1 ──────│────────→│ "hello"                          │      │
│  └──────────┘         │ refcount: 1                      │      │
│                       └──────────────────────────────────┘      │
│                                                                 │
│  s2 = s1                                                        │
│  ┌──────────┐         ┌──────────────────────────────────┐      │
│  │ s1 ──────│────┬───→│ "hello"                          │      │
│  └──────────┘    │    │ refcount: 2  ← カウントが増える！ │      │
│  ┌──────────┐    │    └──────────────────────────────────┘      │
│  │ s2 ──────│────┘                                              │
│  └──────────┘                                                   │
│                                                                 │
│  del s1                                                         │
│  ┌──────────┐         ┌──────────────────────────────────┐      │
│  │ s2 ──────│────────→│ "hello"                          │      │
│  └──────────┘         │ refcount: 1  ← カウントが減る    │      │
│                       └──────────────────────────────────┘      │
│                                                                 │
│  del s2                                                         │
│                       ┌──────────────────────────────────┐      │
│                       │ refcount: 0  → 解放！            │      │
│                       └──────────────────────────────────┘      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「参照カウントで管理してるから、両方使えるんですね。便利…」
>
> 👩‍🏫 **レイ**: 「でも、その便利さには代償があるの。」

```
参照カウント方式のコスト:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. 毎回カウントを更新する（代入のたびにインクリメント）         │
│     → CPUサイクルを消費                                         │
│                                                                 │
│  2. カウント用のメモリが必要（オブジェクトごとに追加バイト）     │
│     → メモリ使用量が増える                                      │
│                                                                 │
│  3. 循環参照の問題（A→B→A→B→...）                               │
│     → 別途サイクル検出GCが必要                                  │
│                                                                 │
│  4. マルチスレッドではアトミック操作が必要                       │
│     → さらに遅くなる                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「あぁ…だからRustは所有権方式を選んだんですね。実行時のコストがゼロだから。」
>
> 👩‍🏫 **レイ**: 「そういうこと！学習コストは高いけど、実行時のパフォーマンスは圧倒的よ。」

---

## Copyトレイト — ムーブしない型

> 👩‍💻 **ユイ**: 「あれ、でも整数とかはムーブしないですよね？」

```rust
fn main() {
    let x = 5;
    let y = x;  // コピー（ムーブではない）

    println!("x = {}, y = {}", x, y);  // ✅ 両方使える
}
```

> 👩‍🏫 **レイ**: 「よく気づいたわね！整数みたいな**スタック上に収まる単純な型**は、代入時に『ムーブ』じゃなくて『コピー』されるの。」
>
> 👩‍💻 **ユイ**: 「なんでですか？」

### なぜ整数はコピーなのか？

> 👩‍🏫 **レイ**: （ホワイトボードに描く）「整数のメモリ表現を見てみましょう。」

```
整数のメモリ表現:

let x = 5;
┌─────────────────┐
│ x: 5            │  ← スタック上に直接値が入る（ヒープを使わない）
└─────────────────┘

let y = x;
┌─────────────────┐
│ x: 5            │  ← そのまま
└─────────────────┘
┌─────────────────┐
│ y: 5            │  ← 値をコピー（コストは無視できるほど小さい）
└─────────────────┘
```

> 👩‍🏫 **レイ**: 「整数は4バイトで固定だから、スタック上に直接値が入るの。ヒープを使わないから、コピーしても二重解放の心配がないわ。」
>
> 👩‍💻 **ユイ**: 「なるほど！ヒープを使う型（Stringとか）はムーブ、スタックだけの型はコピーなんですね。」
>
> 👩‍🏫 **レイ**: 「完璧！」

**Copy可能な条件:**
1. スタック上に完全に収まる（ヒープを使わない）
2. コピーのコストが非常に小さい

**Copyトレイトを実装している型:**
- 整数型（`i32`, `u64`など）
- 浮動小数点数（`f32`, `f64`）
- ブール型（`bool`）
- 文字型（`char`）
- 上記のみで構成されるタプル（例: `(i32, bool)`）

**ヒープを使う型**（`String`, `Vec<T>`, `Box<T>`など）は**ムーブ**します。

---

## 借用（Borrowing）— 所有権を渡さずに使う

> 👩‍💻 **ユイ**: 「でも、毎回ムーブしてたら不便じゃないですか？関数に渡したら使えなくなっちゃうし…。」
>
> 👩‍🏫 **レイ**: 「そう！だから**借用（Borrowing）**っていう仕組みがあるの。『値を使いたいけど、所有権は渡したくない』って場面で使うわ。」
>
> 👩‍💻 **ユイ**: 「借用…図書館で本を借りるみたいな？」
>
> 👩‍🏫 **レイ**: 「まさにそのイメージよ！Chapter 01で予告したわね。」

### 不変の借用（`&`）

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // &s = sへの参照（借用）
    println!("'{}' の長さは {}", s, len);  // sはまだ使える！
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // sは借用なので、ここでdropされない
```

> 👩‍💻 **ユイ**: 「おお！`&s`にすると、`s`がまだ使えるんですね！」
>
> 👩‍🏫 **レイ**: 「そう。`&`は**参照を作る演算子**よ。これも物理的に何が起きてるか見てみましょう。」

### 参照のメモリレイアウト

> 👩‍🏫 **レイ**: （ホワイトボードに描く）

```
┌─────────────────────────────────────────────────────────────────┐
│  借用（&s）のメモリ状態                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  main関数のスタックフレーム                                      │
│  ┌───────────────────────────────────────┐                      │
│  │ s: String                             │                      │
│  │   ptr: 0x5f3e2a10 ─────────────────────────────→ ヒープ      │
│  │   len: 5                              │              │       │
│  │   capacity: 5                         │              ↓       │
│  └───────────────────────────────────────┘        ┌─────────┐  │
│                                                   │ "hello" │  │
│  calculate_length関数のスタックフレーム            └─────────┘  │
│  ┌───────────────────────────────────────┐              ↑       │
│  │ s: &String (参照)                     │              │       │
│  │   ptr: 0x7fff1234 ──────→ mainのs ────────────────────┘       │
│  └───────────────────────────────────────┘                      │
│         ↑                                                       │
│    8バイトだけ！（64bit環境）                                    │
│                                                                 │
│  参照 = 「所有者のアドレス」を持つポインタ                       │
│  → 所有権は移動しない、sを経由してデータにアクセス               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「参照って、ポインタのポインタみたいな感じですか？」
>
> 👩‍🏫 **レイ**: 「概念的にはそう。重要なのは、**参照は所有権を持たない**ってこと。だから関数が終わっても、元の`s`は解放されないの。」
>
> 👩‍💻 **ユイ**: 「借りてるだけだから、返す必要があるんですね。」
>
> 👩‍🏫 **レイ**: 「その通り！」

**`&String`型の読み方:**
- `&` = 参照
- `String` = 参照先の型
- つまり「Stringへの不変参照」

> 👩‍💻 **ユイ**: 「Pythonだと常に参照渡しみたいな感じですけど、Rustは明示的に`&`を書くんですね。」
>
> 👩‍🏫 **レイ**: 「その通り！Rustは**暗黙を嫌う**の。コードを読めば何が起きてるか一目でわかるのよ。これ、大規模なコードベースでは本当にありがたいわ。」

### 可変の借用（`&mut`）

> 👩‍🏫 **レイ**: 「値を**変更したい**場合は`&mut`（可変参照）を使うわ。」

```rust
fn main() {
    let mut s = String::from("hello");  // mutが必要
    change(&mut s);
    println!("{}", s);  // "hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

> 👩‍💻 **ユイ**: 「あっ、`let mut`と`&mut`の両方が必要なんですね。」
>
> 👩‍🏫 **レイ**: 「そう。1行ずつ読み解いてみましょう。」

### `&mut`を行ごとに読み解く

```rust
let mut s = String::from("hello");
```

> 👩‍🏫 **レイ**: 「`let mut` = 変更可能な変数として宣言。これがないと可変参照を作れないわ。」

```rust
change(&mut s);
```

> 👩‍🏫 **レイ**: 「`&mut s` = sへの**可変**参照を作成。『sを変更可能な状態で貸し出す』って意味よ。」

```rust
fn change(s: &mut String) {
```

> 👩‍🏫 **レイ**: 「`s: &mut String` = 『Stringへの可変参照』を受け取る。この関数内でsを変更できるわ。」

```rust
s.push_str(", world");
```

> 👩‍🏫 **レイ**: 「可変参照を通じて、元のStringに文字列を追加。`main`関数の`s`が実際に変更されるの。」
>
> 👩‍💻 **ユイ**: 「なるほど！可変参照は『変更する権限を借りる』イメージですね。」

---

## 借用の3つのルール — データ競合を防ぐ

> 👩‍🏫 **レイ**: 「借用には**超重要な3つのルール**があるわ。これがRustの安全性の核心よ。」

（レイがホワイトボードに大きく書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  借用のルール（The Borrowing Rules）                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ルール1: 不変参照（&T）は【同時にいくつでも】OK                  │
│           → 「読む人は何人いてもOK」                             │
│                                                                 │
│  ルール2: 可変参照（&mut T）は【同時に1つだけ】                   │
│           → 「書く人は1人だけ」                                  │
│                                                                 │
│  ルール3: 不変参照と可変参照は【同時に存在できない】              │
│           → 「誰かが読んでる間は書き込み禁止」                   │
│                                                                 │
│  まとめ: 「読み取りは共有OK、書き込みは排他的」                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「えっ、可変参照は**1つだけ**なんですか！？厳しすぎません？」
>
> 👩‍🏫 **レイ**: 「厳しいわよね。でも、これには**深い理由**があるの。ちょっと現場の話をさせて。」

### なぜこのルールが必要か — 実際のバグの話

> 👩‍🏫 **レイ**: 「先月、隣のチームで本番障害があったの。原因はこういうコードだったわ。」

```javascript
// JavaScript（実際のバグ）
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" }
];

// ユーザーを反復しながら削除 → バグ！
users.forEach((user, index) => {
    if (user.name.startsWith("B")) {
        users.splice(index, 1);  // 反復中に配列を変更！
    }
});

console.log(users);
// 期待: Alice, Charlie
// 実際: Alice, Charlie... でも実はCharlieがスキップされることも！
```

> 👩‍💻 **ユイ**: 「あっ、これ私もやったことあります！反復中に削除するとインデックスがズレるんですよね…」
>
> 👩‍🏫 **レイ**: 「そう。これが**『読んでいる間に書き込む』問題**よ。Rustなら**コンパイルエラー**になるの。」

```rust
fn main() {
    let mut users = vec!["Alice", "Bob", "Charlie"];
    
    for user in &users {  // 不変参照でイテレート
        if user.starts_with("B") {
            users.retain(|u| !u.starts_with("B"));  // ❌ コンパイルエラー！
            // error: cannot borrow `users` as mutable because it is also 
            //        borrowed as immutable
        }
    }
}
```

> 👩‍💻 **ユイ**: 「おお…！コンパイル時に防いでくれる…！」
>
> 👩‍🏫 **レイ**: 「そう。JavaScriptやPythonだと**実行時に**おかしな挙動になる。Rustは**コンパイル時に**ブロックするの。」

### 具体例で理解する

**OK: 不変参照は複数持てる**

```rust
fn main() {
    let s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &s;  // いくつでもOK

    println!("{}, {}, {}", r1, r2, r3);
}
```

> 👩‍💻 **ユイ**: 「読み取りだけなら何個でもいいんですね。」

**OK: 参照を使い終わった後なら可変参照を作れる**

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);  // r1, r2はここで最後の使用

    // r1, r2はもう使われない → 可変参照を作れる
    let r3 = &mut s;
    println!("{}", r3);
}
```

> 👩‍🏫 **レイ**: 「ポイントは、『参照が使われなくなったタイミング』でライフタイムが終わることよ。」

**NG: 不変参照と可変参照の同時使用**

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;          // 不変参照
    let r2 = &mut s;      // ❌ エラー！

    println!("{}, {}", r1, r2);
}
```

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:14
  |
4 |     let r1 = &s;
  |              -- immutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ mutable borrow occurs here
6 |     println!("{}, {}", r1, r2);
  |                        -- immutable borrow later used here
```

> 👩‍💻 **ユイ**: 「また怒られた…。」
>
> 👩‍🏫 **レイ**: 「でも、エラーメッセージ読んでみて。『immutable borrowがあるからmutable borrowできない』って書いてあるでしょ？」
>
> 👩‍💻 **ユイ**: 「確かに…！親切ですね。」

### データ競合の3条件 — コンピュータサイエンスの基礎

> 👩‍🏫 **レイ**: 「ここからちょっと理論的な話になるけど、大事だから聞いて。」

（レイがホワイトボードに書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  データ競合（Data Race）の発生条件                               │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  以下の3つが【すべて】満たされると発生:                          │
│                                                                 │
│  1. 2つ以上のポインタが同じデータにアクセス                      │
│  2. 少なくとも1つが【書き込み】                                  │
│  3. アクセスが【同期されていない】                               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Rustの借用ルールは、条件1と2を【コンパイル時に】チェック        │
│                                                                 │
│  「読み取りだけなら複数OK」 → 条件2を回避                        │
│  「書き込みは1つだけ」     → 条件1を回避                        │
│  「読み書き同時は禁止」    → 条件1+2を回避                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「なるほど…！借用ルールって、データ競合の条件を**物理的に満たせなくする**ための仕組みなんですね。」
>
> 👩‍🏫 **レイ**: 「そう！他の言語では**実行時**にロックを使って条件3（同期）を満たすけど、Rustは**コンパイル時**に条件1・2を満たせなくするの。だからランタイムコストがゼロ！」
>
> 👩‍💻 **ユイ**: 「設計が美しいですね…！」
>
> 👩‍🏫 **レイ**: 「でしょ？これがRustが『安全性とパフォーマンスを両立』って言われる理由よ。」

---

## ライフタイム — 参照の有効期間

> 👩‍🏫 **レイ**: 「次は**ライフタイム**。参照が『どのくらい生きているか』を表すわ。」

### ダングリング参照の防止

```rust
fn main() {
    let r;                // ← rをここで宣言
    {
        let x = 5;
        r = &x;           // ← xへの参照をrに代入
    }                     // ← xがここで破棄される
    println!("{}", r);    // ❌ xはもう存在しない！
}
```

```
error[E0597]: `x` does not live long enough
 --> src/main.rs:5:13
  |
4 |         let x = 5;
  |             - binding `x` declared here
5 |         r = &x;
  |             ^^ borrowed value does not live long enough
6 |     }
  |     - `x` dropped here while still borrowed
7 |     println!("{}", r);
  |                    - borrow later used here
```

> 👩‍💻 **ユイ**: 「『does not live long enough』…xが十分長く生きてないって言われてる…。」
>
> 👩‍🏫 **レイ**: 「そう！Rustコンパイラは『rがxより長生きしようとしている』ことを検出して、エラーにしてくれるの。」

### コンパイラはどうやって検出するか

> 👩‍🏫 **レイ**: （ホワイトボードに描く）「コンパイラは各変数に**ライフタイム**（生存期間）を割り当ててるのよ。」

```rust
fn main() {
    let r;                // ─────────┐ 'a: rのライフタイム
    {                     //          │
        let x = 5;        // ─┐ 'b    │
        r = &x;           //  │       │
    }                     // ─┘ xが'bで終了、しかしrは'aで続く
    println!("{}", r);    //          │
}                         // ─────────┘
```

> 👩‍🏫 **レイ**: 「`'b`（xのライフタイム）が`'a`（rのライフタイム）より短いから、エラーになるの。」
>
> 👩‍💻 **ユイ**: 「なるほど…！コンパイラが『無効な参照』を検出してくれるんですね。」
>
> 👩‍🏫 **レイ**: 「そう。C言語だとこれが**ダングリングポインタ**っていう深刻なバグになるのよ。」

---

## ライフタイム注釈 `'a` — 明示的なライフタイム指定

> 👩‍🏫 **レイ**: 「関数が**参照を返す**場合、コンパイラに『戻り値がどこまで有効か』を教える必要があるわ。」

### なぜライフタイム注釈が必要か

```rust
// ❌ コンパイルエラー！
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value,
          but the signature does not say whether it is borrowed from `x` or `y`
```

> 👩‍💻 **ユイ**: 「『xから借りてるのか、yから借りてるのか分からない』って言われてる…。」
>
> 👩‍🏫 **レイ**: 「そう！戻り値の参照は`x`から来るかもしれないし、`y`から来るかもしれない。コンパイラは『どちらのライフタイムを使えばいいか』わからないの。」

### ライフタイム注釈の書き方

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

> 👩‍💻 **ユイ**: 「`'a`って何ですか！？アポストロフィ？」
>
> 👩‍🏫 **レイ**: 「これがライフタイム注釈よ。読み方を教えるわね。」

### `'a`を読み解く

> 👩‍🏫 **レイ**: （ホワイトボードに書く）

```
┌─────────────────────────────────────────────────────────────────┐
│  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  <'a>                                                           │
│    └─ ライフタイムパラメータを宣言（型パラメータ<T>と同じ位置）   │
│                                                                 │
│  x: &'a str                                                     │
│    └─ 「xはライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  y: &'a str                                                     │
│    └─ 「yもライフタイム'aの間有効な&strへの参照」                │
│                                                                 │
│  -> &'a str                                                     │
│    └─ 「戻り値もライフタイム'aの間有効」                         │
│                                                                 │
│  意味:                                                           │
│  「xとyの両方が有効な間、戻り値も有効」                          │
│  → 実際には「xとyの短い方」のライフタイムが'aになる              │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「うーん…難しいですね…。」
>
> 👩‍🏫 **レイ**: 「最初はね。でも大丈夫、ほとんどの場合コンパイラが推論してくれるわ。エラーが出たら、エラーメッセージに従って追加すればいいの。」
>
> 👩‍💻 **ユイ**: 「そっか、またコンパイラと対話すればいいんですね。」
>
> 👩‍🏫 **レイ**: 「その調子！」

### よく使うライフタイム

| ライフタイム | 意味 |
|------------|------|
| `'a`, `'b` | 一般的なライフタイムパラメータ |
| `'static` | プログラム全体で有効（文字列リテラルなど） |
| `'_` | ライフタイムの省略（コンパイラが推論） |

**`'static`の例:**

```rust
let s: &'static str = "Hello, world!";  // 文字列リテラルは'static
```

> 👩‍🏫 **レイ**: 「文字列リテラルは、プログラムのバイナリに埋め込まれるから、プログラム全体で有効なの。だから`'static`。」

---

## 実践パターン

> 👩‍🏫 **レイ**: 「最後に、よく使うパターンをまとめておくわね。これは実務で**めちゃくちゃ使う**から、暗記レベルで覚えて。」

### パターン1: 関数に値を渡す3つの方法

```rust
// 1. 所有権を取る（呼び出し元は使えなくなる）
fn takes_ownership(s: String) {
    println!("{}", s);
}  // sがdropされる

// 2. 不変借用（呼び出し元も使える、変更不可）
fn borrows(s: &String) {
    println!("{}", s);
}  // sは借用なのでdropされない

// 3. 可変借用（変更できる）
fn mutates(s: &mut String) {
    s.push_str("!");
}

fn main() {
    let s1 = String::from("hello");
    takes_ownership(s1);
    // println!("{}", s1);  // ❌ s1はムーブ済み

    let s2 = String::from("hello");
    borrows(&s2);
    println!("{}", s2);  // ✅ OK "hello"

    let mut s3 = String::from("hello");
    mutates(&mut s3);
    println!("{}", s3);  // ✅ OK "hello!"
}
```

> 👩‍💻 **ユイ**: 「状況に応じて使い分けるんですね。どれを使えばいいか迷います…」
>
> 👩‍🏫 **レイ**: 「現場の目安を教えるわね。」

```
┌─────────────────────────────────────────────────────────────────┐
│  どれを使うか？ — 実務ガイド                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Q: 関数内で値を変更する？                                       │
│    No  → &T（不変借用）を使う 【80%のケース】                    │
│    Yes → &mut T（可変借用）を使う                                │
│                                                                 │
│  Q: 値の所有権を完全に移す必要がある？                           │
│    No  → 借用（&T or &mut T）                                   │
│    Yes → 所有権を取る（T）                                      │
│         例: 構造体のフィールドに格納する                         │
│         例: スレッドに渡す                                      │
│         例: 関数内で消費する（dropする）                         │
│                                                                 │
│  迷ったら: まず &T で書いて、コンパイラに怒られたら変更          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 👩‍💻 **ユイ**: 「8割が不変借用なんですか！」
>
> 👩‍🏫 **レイ**: 「そう。**デフォルトは借用**って覚えておいて。所有権を取るのは『本当に必要なとき』だけよ。」

### パターン2: clone()で明示的にコピー

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深いコピー（ヒープデータもコピー）

    println!("s1 = {}, s2 = {}", s1, s2);  // ✅ 両方使える
}
```

> 👩‍🏫 **レイ**: 「本当にコピーが必要なら`clone()`を使うわ。でも、ヒープデータもコピーするから**コストがかかる**のよ。」
>
> 👩‍💻 **ユイ**: 「必要な場合のみ使うんですね。」

---

## まとめ

> 👩‍🏫 **レイ**: 「長かったわね。今日はRustの核心に触れたわ。」

| 概念 | 説明 | Python/TSとの違い |
|-----|------|------------------|
| 所有権 | 値には所有者が1つだけ | GC言語では意識不要 |
| ムーブ | 代入で所有権が移動（スタック上24バイトのコピー） | 参照のコピー（両方使える） |
| `&`（借用） | 不変参照を作成（読み取りのみ） | 明示的に書く必要がある |
| `&mut` | 可変借用（同時に1つだけ） | 制限なし（データ競合のリスク） |
| ライフタイム`'a` | 参照の有効期間 | GCが管理（予測不能） |

> 👩‍💻 **ユイ**: 「めちゃくちゃ頭使いました…。でも、なんか**パズルが解けていく感覚**がありました！」
>
> 👩‍🏫 **レイ**: 「いい表現ね。所有権って、最初は『制約』に見えるけど、慣れると『設計のガイドライン』になるのよ。」
>
> 👩‍💻 **ユイ**: 「どういうことですか？」
>
> 👩‍🏫 **レイ**: 「『この関数は所有権を取るべきか、借用で十分か？』って考えるようになると、自然と**責任の所在が明確なコード**が書けるようになるの。」
>
> 👩‍💻 **ユイ**: 「あぁ…確かに、『誰がこのデータの責任を持つか』を常に意識しますね。」
>
> 👩‍🏫 **レイ**: 「それがRustの哲学よ。**『暗黙』を排除して、すべてを明示する』**。最初は面倒に感じるけど、大規模プロジェクトでは本当に助かるわ。」
>
> 👩‍💻 **ユイ**: 「はい！コンパイラと仲良くなります！」
>
> 👩‍🏫 **レイ**: 「その調子。Rustのコンパイラは厳しいけど、**最高のコードレビュアー**だと思えばいいわ。いつも的確なフィードバックをくれるから。」

---

## ポイント

- **なぜ所有権が必要か**: GCは便利だが、予測不能な停止・メモリ増大・CPUオーバーヘッドがある
- **Rustの革新**: メモリの有効期間を**コンパイル時に**決定 → 実行時コストゼロ
- **所有権の3ルール**: 所有者は1つ、スコープを抜けたら解放、代入でムーブ
- **ムーブの物理**: スタック上24バイト（ptr/len/cap）のコピー、ヒープは共有→だから無効化
- **借用のルール**: 読み取りは共有OK、書き込みは排他的 → **データ競合を原理的に防止**
- **コンパイラは味方**: エラーは「制約」ではなく「バグの早期発見」

---

## よくあるコンパイルエラーと対処法

> 👩‍🏫 **レイ**: 「最後に、よく出るエラーと対処法をメモしておくわね。」

**エラー1: `value borrowed here after move`**

```
error[E0382]: borrow of moved value: `s`
```

**原因:** ムーブした後の値を使おうとした
**対処:** `clone()`するか、借用（`&`）を使う

```rust
// ❌ let s2 = s1; println!("{}", s1);
// ✅ let s2 = s1.clone(); println!("{}", s1);
// ✅ let s2 = &s1; println!("{}", s1);
```

**エラー2: `cannot borrow as mutable`**

```
error[E0596]: cannot borrow `s` as mutable, as it is not declared as mutable
```

**原因:** `mut`なしの変数を可変借用しようとした
**対処:** 変数宣言に`mut`を追加

```rust
// ❌ let s = String::from("hello"); s.push_str("!");
// ✅ let mut s = String::from("hello"); s.push_str("!");
```

**エラー3: `does not live long enough`**

```
error[E0597]: `x` does not live long enough
```

**原因:** 参照が参照先より長生きしようとしている
**対処:** ライフタイムを見直す、または所有権を渡す

---

## 次のステップ

> 👩‍🏫 **レイ**: 「次は**構造体と列挙型**よ。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能ね。」
>
> 👩‍💻 **ユイ**: 「所有権の知識を活かすんですね！」
>
> 👩‍🏫 **レイ**: 「そう。特に`self`と`&self`の使い分けが重要よ。楽しみにしててね！」

[Chapter 03: 構造体・列挙型](03-structs-enums-dialogue.md) では、Rustでデータを構造化する方法を学びます。Pythonの`dataclass`、TypeScriptの`interface`に相当する機能です。所有権の知識を活かして、`self`と`&self`の使い分けを理解しましょう。
