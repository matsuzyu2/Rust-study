# Chapter 01: 型と変数

> **この章で学ぶこと**: Rustの型システム、変数宣言、イミュータブルとミュータブル、シャドーイング

---

## Rustは静的型付け言語

Rustは**静的型付け言語**です。すべての変数の型がコンパイル時に決定されます。

🔄 **比較**:

| 言語 | 型システム | 型チェックのタイミング |
|-----|----------|---------------------|
| Python | 動的型付け（型ヒントはオプション） | 実行時 |
| TypeScript | 静的型付け（JavaScriptにトランスパイル） | コンパイル時 |
| Rust | 静的型付け（ネイティブコードにコンパイル） | コンパイル時 |

TypeScriptを使っている人なら、Rustの型システムはすぐに馴染めるでしょう。ただし、いくつかの重要な違いがあります。

---

## 変数宣言: `let`

Rustでは変数を`let`で宣言します。

```rust
fn main() {
    let x = 5;           // 型推論: i32（32ビット整数）
    let y: i32 = 10;     // 明示的な型注釈
    let z: f64 = 3.14;   // 64ビット浮動小数点数
    
    println!("x = {}, y = {}, z = {}", x, y, z);
}
```

🔄 **比較**:

```typescript
// TypeScript
let x = 5;           // 型推論: number
let y: number = 10;  // 明示的な型注釈
const z: number = 3.14;
```

```python
# Python（型ヒント）
x = 5           # 型推論なし（動的）
y: int = 10     # 型ヒント（実行時には無視）
z: float = 3.14
```

---

## 🎯 イミュータブルがデフォルト

**これはRust最大の特徴の一つです。**

Rustでは`let`で宣言した変数は**デフォルトでイミュータブル（不変）**です。

```rust
fn main() {
    let x = 5;
    x = 10;  // ❌ コンパイルエラー！
}
```

変更可能にするには`mut`キーワードを付けます：

```rust
fn main() {
    let mut x = 5;  // mutableと明示
    x = 10;         // ✅ OK
    println!("x = {}", x);
}
```

🔄 **比較**:

| 言語 | デフォルト | 不変にする | 可変にする |
|-----|----------|----------|----------|
| Python | 可変 | なし（慣習的に大文字） | デフォルト |
| TypeScript | 可変（`let`） | `const` | `let` |
| Rust | **不変（`let`）** | デフォルト | `let mut` |

💡 **Tips**: Rustが「イミュータブルデフォルト」を採用している理由：
1. バグの原因となる予期しない変更を防ぐ
2. 並行処理での安全性を高める
3. コンパイラが最適化しやすくなる

⚠️ **注意**: TypeScriptの`const`は「再代入不可」であって「イミュータブル」ではありません。

```typescript
// TypeScript
const arr = [1, 2, 3];
arr.push(4);     // ✅ OK（配列の中身は変更可能）
arr = [5, 6, 7]; // ❌ エラー（再代入は不可）
```

Rustの`let`は本当に変更不可です：

```rust
fn main() {
    let v = vec![1, 2, 3];  // Vec<i32>
    v.push(4);  // ❌ コンパイルエラー！
    
    let mut v = vec![1, 2, 3];
    v.push(4);  // ✅ OK
}
```

---

## 基本的なデータ型

### 数値型

```rust
// 整数型（符号あり）
let a: i8 = 127;          // -128 〜 127
let b: i16 = 32_767;      // 16ビット
let c: i32 = 2_147_483_647;  // デフォルト
let d: i64 = 9_223_372_036_854_775_807;
let e: i128 = 170_141_183_460_469_231_731_687_303_715_884_105_727;
let f: isize = 100;       // ポインタサイズ（32bit/64bit環境依存）

// 整数型（符号なし）
let g: u8 = 255;          // 0 〜 255
let h: u32 = 4_294_967_295;
let i: usize = 100;       // 配列のインデックスに使う

// 浮動小数点数
let j: f32 = 3.14;        // 32ビット
let k: f64 = 3.14159265358979;  // デフォルト、64ビット
```

💡 **Tips**: 数値リテラルでは`_`を区切りとして使えます。`1_000_000`は`1000000`と同じです。

🔄 **比較**:
- Python: `int`（任意精度）、`float`（64ビット）
- TypeScript: `number`（64ビット浮動小数点数のみ）、`bigint`
- Rust: サイズ別に多数の型（メモリ効率を細かく制御可能）

### ブール型

```rust
let t: bool = true;
let f: bool = false;
```

### 文字型

```rust
let c: char = 'A';        // 4バイト（Unicodeスカラー値）
let emoji: char = '🦀';   // 絵文字もOK
```

⚠️ **注意**: `char`は1文字を表し、シングルクォートを使います。文字列はダブルクォートです。

### 文字列型

Rustには2つの文字列型があります：

```rust
// &str: 文字列スライス（不変、スタック上の参照）
let s1: &str = "Hello";

// String: ヒープ上の可変文字列
let s2: String = String::from("Hello");
let s3: String = "Hello".to_string();  // 同じ意味
```

🔄 **比較**:
```typescript
// TypeScript: string一種類のみ
const s: string = "Hello";
```

```python
# Python: str一種類（イミュータブル）
s = "Hello"
```

💡 **Tips**: 最初は「文字列リテラル（`"..."`）は`&str`、`String::from()`で`String`を作る」と覚えておけばOKです。詳しくは所有権の章で解説します。

---

## タプルと配列

### タプル

異なる型の値をまとめられます。

```rust
fn main() {
    let tup: (i32, f64, &str) = (500, 6.4, "hello");
    
    // 分割代入（デストラクチャリング）
    let (x, y, z) = tup;
    println!("x = {}, y = {}, z = {}", x, y, z);
    
    // インデックスアクセス
    let first = tup.0;
    let second = tup.1;
}
```

🔄 **比較**:
```python
# Python
tup = (500, 6.4, "hello")
x, y, z = tup
first = tup[0]
```

```typescript
// TypeScript
const tup: [number, number, string] = [500, 6.4, "hello"];
const [x, y, z] = tup;
```

### 配列

**固定長**で**同じ型**の要素を持ちます。

```rust
fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];  // 型: [要素型; 長さ]
    let first = arr[0];
    
    // 同じ値で初期化
    let zeros: [i32; 10] = [0; 10];  // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
}
```

⚠️ **注意**: Rustの配列は**固定長**です。可変長が必要な場合は`Vec<T>`を使います（Chapter 06で解説）。

---

## シャドーイング

Rustでは同じ名前で変数を再宣言できます。これを**シャドーイング**と呼びます。

```rust
fn main() {
    let x = 5;
    let x = x + 1;      // 新しいxがシャドーイング
    let x = x * 2;      // さらにシャドーイング
    println!("x = {}", x);  // 12
    
    // 型も変えられる！
    let spaces = "   ";           // &str
    let spaces = spaces.len();    // usize（型が変わった）
}
```

🔄 **比較**:
```typescript
// TypeScript: 同じスコープ内で再宣言はできない
let x = 5;
let x = 6;  // ❌ エラー
```

```python
# Python: 再代入は可能（動的型付けなので型も変わる）
x = 5
x = "hello"  # ✅ OK（でも型チェッカーは警告する）
```

💡 **Tips**: シャドーイングは`mut`とは異なります。
- `mut`: 同じ変数の値を変更
- シャドーイング: 新しい変数を作成（以前の変数は隠れる）

```rust
fn main() {
    let mut x = 5;
    x = 10;        // 値を変更（同じ変数）
    
    let x = 5;
    let x = "hello";  // 新しい変数（型も変えられる）
}
```

---

## 型推論

Rustは強力な型推論を持っています。多くの場合、型注釈を省略できます。

```rust
fn main() {
    let x = 5;           // i32と推論
    let y = 3.14;        // f64と推論
    let z = true;        // boolと推論
    
    let mut v = Vec::new();  // Vec<?>（まだ不明）
    v.push(1);               // ここでVec<i32>と確定
}
```

ただし、推論できない場合は型注釈が必要です：

```rust
fn main() {
    let guess: i32 = "42".parse().expect("Not a number!");
    // parseはジェネリックなので、何型にパースするか指定が必要
}
```

🔄 **比較**:
- TypeScript: 同様に型推論が働くが、`any`にフォールバックすることがある
- Rust: **必ず型が決まる**。推論できなければコンパイルエラー

---

## 定数

`const`でコンパイル時定数を定義できます。

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159265358979;

fn main() {
    println!("Max: {}, PI: {}", MAX_POINTS, PI);
}
```

`const`と`let`の違い：

| 特徴 | `let` | `const` |
|-----|-------|---------|
| 型注釈 | 省略可能 | **必須** |
| 値 | 実行時に計算可能 | **コンパイル時に確定** |
| スコープ | ブロック内 | グローバル可 |
| `mut` | 使用可能 | 使用不可 |

---

## 型変換（キャスト）

Rustでは暗黙の型変換がありません。明示的に`as`を使います。

```rust
fn main() {
    let x: i32 = 10;
    let y: i64 = x as i64;  // 明示的にキャスト
    
    let f: f64 = 3.99;
    let i: i32 = f as i32;  // 切り捨て → 3
}
```

🔄 **比較**:
```javascript
// JavaScript: 暗黙の型変換（危険！）
const x = "5" + 3;  // "53"（文字列結合）
const y = "5" - 3;  // 2（数値計算）
```

```rust
// Rust: 暗黙の型変換なし（安全！）
let x = "5" + 3;  // ❌ コンパイルエラー
```

---

## まとめ

| 概念 | Python/TS | Rust |
|-----|-----------|------|
| 変数宣言 | `let`/`const`、型ヒント | `let`（イミュータブル）、`let mut`（ミュータブル） |
| デフォルト | ミュータブル | **イミュータブル** |
| 型推論 | あり | あり（ただし曖昧なら必須） |
| 型変換 | 暗黙あり | **明示的（`as`）** |
| シャドーイング | なし/動的 | あり（型も変更可能） |
| 文字列 | 1種類 | `&str`（スライス）と`String`（ヒープ） |

🎯 **ポイント**: 
- Rustは「イミュータブルデフォルト」— 変更するつもりなら`mut`と明示
- 型変換は常に明示的 — バグの温床となる暗黙変換を排除
- コンパイラが型を推論できなければエラー — 曖昧さを許さない

---

## 次のステップ

[Chapter 02: 所有権](02-ownership.md) では、Rust最大の特徴である「所有権システム」を学びます。これはPython/TypeScriptには存在しない概念で、Rustを理解する上で最も重要なトピックです。
